[{"content":"您在位置 #5951-5958的标注 | 添加于 2021年6月28日星期一 下午10:16:56\n驿站长走进来，低首下心地请求他大人再等那么两小时，两小时后他一定给他弄到驿马。驿站长显然在撒谎，他一心想从旅客身上多弄几个钱，“这是好事还是坏事？”皮埃尔自问，“在我是好事，在别的旅客可是坏事，他却非如此不可，因为他没有钱买食物。他说，他还因此挨了一个军官的打。军官之所以打他，因为急于赶路。我之所以向陶洛霍夫开枪，因为我受了侮辱。而路易十六上断头台，因为他被认为是个罪人，一年后那些处死他的人也因故被杀了。什么是恶？什么是善？什么应该爱，什么应该恨？活着为了什么？我是什么人？什么叫生，什么叫死？是什么力量在支配一切？”他问着自己。但这些问题一个也没有得到解答，只有一个解答既不合逻辑，又同这些问题无关。这个解答就是：“你一死就一了百了。你一死就会明白一切，要么你就别再发问。”但死也是很可怕的。\n========== 您在位置 #6038-6041的标注 | 添加于 2021年6月28日星期一 下午10:23:30\n阁下，看看你的生活吧。你是怎么度过的？纵酒狂饮，荒淫无度。你从社会上获得一切，却不给社会任何东西。你获得了财富，但你怎样使用它呢？你为亲人做了什么呢？你想到过你的成千上万的农奴吗？你在物质上和精神上帮助过他们吗？没有。你利用他们的劳动过放荡的生活。嗯，这就是你所做的。你有没有选择过一项造福他人的活动？没有。你饱食终日，无所事事。\n========== 您在位置 #6061-6064的标注 | 添加于 2021年6月28日星期一 下午10:25:17\n他走后好久，皮埃尔一直没有躺下睡觉，也没打听马匹，却在驿站房间里来回踱步，回想着自己荒唐的往事，同时怀着新生的喜悦展望着他认为容易获得的高尚、完美和幸福的未来。他觉得他原来生活荒唐，只因为偶尔忘记了做个善良的人是多么幸福。\n========== 您在位置 #6524-6528的标注 | 添加于 2021年6月28日星期一 下午10:56:22\n“不，杀人是不好的，不对的……” “为什么不对呢？”安德烈公爵重复说，“什么对，什么不对，人是无法判断的。人总是弄不清楚，永远弄不清楚，尤其在是非问题上。” “凡是对别人有害的事都是错的。”皮埃尔说，高兴地发觉自从他来到这里以后，安德烈公爵第一次兴奋起来，开始想说话，说出他怎么会变成现在这个样子的。 “谁告诉过你，什么事是对别人有害的？”安德烈公爵问。\n========== 您在位置 #6524-6535的标注 | 添加于 2021年6月28日星期一 下午10:58:09\n“不，杀人是不好的，不对的……” “为什么不对呢？”安德烈公爵重复说，“什么对，什么不对，人是无法判断的。人总是弄不清楚，永远弄不清楚，尤其在是非问题上。” “凡是对别人有害的事都是错的。”皮埃尔说，高兴地发觉自从他来到这里以后，安德烈公爵第一次兴奋起来，开始想说话，说出他怎么会变成现在这个样子的。 “谁告诉过你，什么事是对别人有害的？”安德烈公爵问。 “有害？有害？”皮埃尔说，“我们全都知道，什么事对自己有害。” “是的，我们知道，但我不能把对自己有害的事加在别人身上，”安德烈公爵越说越兴奋，显然想把自己的新观点告诉皮埃尔，他用法语说下去，“我知道人生有两大真正的不幸：悔恨和疾病。没有这两种不幸就是幸福。为自己生活，避免这两种不幸，这就是我现在的全部人生哲学。” “那么，爱别人和自我牺牲呢？”皮埃尔说，“不，我不能同意您的看法！活着光是不害人，不悔恨，那是不够的。我以前就是这样生活的，我活着为了自己，结果反而毁了自己的生活。现在我才为别人而生活，至少努力为别人而生活（由于谦逊，皮埃尔纠正了自己的话）；现在我才懂得生活的全部幸福。不，我不同意您的看法，您说这话也未必出于真心。”\n========== 您在位置 #6536-6540的标注 | 添加于 2021年6月28日星期一 下午10:59:13\n安德烈公爵说，“也许对你自己来说你是对的，”他沉默了一会儿继续说，“但每个人都在按自己的意愿生活：你以前为自己活着，你说你几乎毁了你的生活，直到你开始为别人生活，你才懂得了幸福。可我的经历正好相反。我以前为荣誉而活（什么是荣誉？荣誉就是爱别人，就是愿意为他们做些什么，愿意得到他们的称赞）。我以前就这样为别人而生活，结果不是几乎而是完全毁了自己的生活。直到我只为自己生活，我心里才觉得平静。”\n========== 您在位置 #6544-6552的标注 | 添加于 2021年6月28日星期一 下午11:00:31\n“您在开玩笑，”皮埃尔越来越兴奋地说，“我想做点好事——虽然做得很少很差，但我想做，而且多少做了一点——这有什么错误和罪过呢？不幸的人们，我们的农奴，同我们一样是人，但他们从小到大直到死，除了知道神像和无意义的祷告之外，对上帝和真理一无所知。要是有人引导他们相信来生、报应、奖赏和归宿，那又有什么罪过呢？要是有人害病濒临死亡而得不到救援——其实在物质上援助他们是轻而易举的——我给他们医生，让他们住院，我收养老人，这又有什么错误和罪过呢？要是农夫、农妇带着孩子白天黑夜不停地干活，我让他们有时间休息，这难道不是切切实实的好事吗？……”皮埃尔急促而口齿不清地说，“我做了这些事，虽然做得不好，做得不多，但多少做了一点。我认为这样做是好的，您不仅不能动摇我的信心，而且我深信您内心并不真正这样想。而主要的是，”皮埃尔继续说，“我知道，确确实实知道，做好事是人生唯一的幸福。”\n========== 您在位置 #6552-6554的标注 | 添加于 2021年6月28日星期一 下午11:00:48\n“哦，要是这样提出问题，那可是另一回事了，”安德烈公爵说，“我盖房子，辟花园，你盖医院。做这些事都可以消磨时光。至于什么事对，什么事好，还是让那些无所不知的人去判断吧，我们可不能判断。你想争论，那就来吧。”他们离开餐桌，坐到代替阳台的门前台阶上。\n========== 您在位置 #6555-6558的标注 | 添加于 2021年6月28日星期一 下午11:01:13\n“好，让我们来争论吧！”安德烈公爵说，“你说到学校，”他弯下一个手指说下去，“教育，等等，你想使他……”他指指一个摘下帽子从他们旁边走过的农夫说，“使他摆脱畜生般的状态，产生精神上的需要。可我认为畜生的幸福是他唯一可以获得的幸福，而你却要剥夺他这种幸福。我羡慕他，你却要使他变成像我这样的人，但又不给他我那样的智慧、感情和财富。\n========== 您在位置 #6571-6572的标注 | 添加于 2021年6月28日星期一 下午11:02:41\n“为什么不洗脸，不洗不卫生，”安德烈公爵说，“相反，应该尽量使自己的生活过得愉快些。我活在世界上，这又不是我的错，因此我要过得好些，不妨碍任何人，过完这一生。”\n========== 您在位置 #7135-7137的标注 | 添加于 2021年6月28日星期一 下午11:40:21\n这棵栎树在安德烈心中勾起一连串消极、悲怆而又愉快的思想。在整个旅途中，他仿佛重新思考了自己的一生，并又得出安于现状的消极结论，觉得他没有必要再开创什么，只要不作恶，不忧虑，摆脱欲望，享尽天年就行了。\n========== 您在位置 #7186-7190的标注 | 添加于 2021年6月28日星期一 下午11:44:30\n“对，生命不能在三十一岁上结束，”安德烈公爵突然斩钉截铁地说，“我心里有什么感觉，只有我自己知道是不够的，应该让人人都知道：应该让皮埃尔知道，让那个想飞上天去的姑娘知道，要让人人都了解我，我活着不能只为我自己，也不能让大家都像那个姑娘似的不关心我的存在，我的生命要在大家身上反映出来，要使大家都同我一起生活！”\n========== 您在位置 #7321-7323的标注 | 添加于 2021年6月28日星期一 下午11:52:07\n佩兰斯基在安德烈公爵面前竭力卖弄他那公正而冷静的思维能力，并且微妙地奉承安德烈公爵。这种奉承夹杂着一种自负，暗示只有他们两人深知众人的愚蠢和自己思想的明智与深刻。\n========== 您在位置 #8112-8115的标注 | 添加于 2021年7月2日星期五 上午12:50:51\n“难道真是我，我这个被大家唤作小姑娘的人，”娜塔莎想，“难道我今后就要成为这个陌生、聪明、可爱、甚至受我父亲尊敬的人的妻子吗？难道这是真的吗？难道从今以后我真的不能把生活当儿戏了吗？现在我已经长大了，就得对自己的一言一行负责吗？哦，他问我什么啦？”\n","permalink":"https://abigail1985.github.io/essay/war-and-peace/","summary":"","title":"《战争与和平》书摘"},{"content":"您在第 448 页（位置 #7985-7986）的标注 | 添加于 2020年12月12日星期六 下午6:24:42\n宗教也许是最好的道德学校，就像你们给病人开的某种用作溶剂的药。它可能本身没有效果，却能使别的药物更好地吸收。你建立起自己的道德观，因为它本身就是和宗教相结合的；你放弃了宗教信仰，可是道德观还是不变的。\n========== 您在第 490 页（位置 #8719-8721）的标注 | 添加于 2020年12月12日星期六 下午7:05:02\n我记得自己曾经因为你的所作所为而觉得你是个恶毒残忍的女人。但我太傻了。你只是不爱我罢了，我不能因为这点就怪罪于你。我以为能让你爱上我，但是我现在知道了，这根本就不可能。我不知道怎么才能让一个人爱上自己。\n========== 您在第 541 页（位置 #9621-9624）的标注 | 添加于 2020年12月12日星期六 下午7:40:40\n贤士用一句话把人的一辈子概括给他听：生而受难，久难而终。生命没有意义。人活着没有目的。一个人是否降生在这世上，是否还活着或已经死去，这些都是无关紧要的事。生命微不足道，死亡更无足轻重。菲利普欢喜若狂，就像小时候刚刚摆脱对上帝的信仰时的感觉一样：似乎人生中最后一重枷锁已经从他身上卸掉，他第一次感受到了彻底的自由。\n========== 您在第 554 页（位置 #9849-9852）的标注 | 添加于 2020年12月12日星期六 下午7:51:38\n这天地之间有不可计数的人，对于他们来说生活只是无休止的劳作，既谈不上美好，又称不得丑陋。春花秋月，夏蝉冬雪，四季更替似乎不过轮回一瞥。他们就是如此在生活中木然老去。人生是没有意义的，这让菲利普胸中怒火骤起。他不能接受这个事实，可自己的所见所想偏偏让他不得不信。\n========== 您在第 588 页（位置 #10427-10429）的标注 | 添加于 2020年12月12日星期六 下午8:15:36\n他们坦然接受命运的安排，深谙“天行有常”之道。再者说，如果不这样坦然接受……老天啊！如果不能坦然接受的话，他们也许就成群成群地扎进河里，跑到对岸那些高楼大厦里面纵火抢劫了。\n========== 您在第 593 页（位置 #10514-10517）的标注 | 添加于 2020年12月12日星期六 下午8:22:25\n他曾听别人谈起钱来非常不屑，不知道这些人有没有经历过没钱的日子。若是一个人口袋空空，就会变得斤斤计较、吝啬小气、贪得无厌。贫穷会扭曲人的心理，让他不得不以一种恶俗的视角来看待世界。当你每花一分钱都必须要精打细算的时候，钱就会变得离奇的重要。你需要培养一种能力，使自己可以正确衡量金钱的价值。\n========== 您在第 623 页（位置 #11050-11051）的标注 | 添加于 2020年12月12日星期六 下午8:44:34\n他想象着和萨莉在那座小渔村里的生活。他们将有一座面朝大海的小屋，巨大的轮船远远驶来，又朝着他永远也不会知道的陌生大陆驶去。也许这才是最明智的选择吧。\n==========\n您在第 623 页（位置 #11053-11057）的标注 | 添加于 2020年12月12日星期六 下午8:45:05\n准备放弃所有的远大理想，将自我牺牲作为献给新婚妻子的最好礼物。这是多么美妙的事啊，他整整想了一夜，激动得看不下去书。一种无形的力量把他拽出屋子，推到了大街上。他沿着伯德卡基的人行道信步往返，心脏兴奋而剧烈地跳动着。他一刻也不想等待下去了，恨不能立刻就去找萨莉说出他的决定，迫不及待地想看到萨莉幸福的样子。如果不是时候太晚，他可能现在已经站在萨莉家的大门外了。他想象着和她依偎在一间舒适惬意的客厅，百叶窗敞开着，波光粼粼的大海就在眼前。\n========== 您在第 624 页（位置 #11062-11065）的标注 | 添加于 2020年12月12日星期六 下午8:46:02\n只瘸腿让他的性格扭曲，可也赋予他内省的能力，让他能因此而自得其乐。倘若他的肢体是健全的，也许就不会对美有如此独到的鉴赏力，不会这样热烈地崇尚艺术和文学，也不会因生命百态而兴致勃勃。在他身上日积月累的讥讽嘲笑让他渐渐筑起心墙，催开了芳香不逝的花朵。\n========== 您在第 624 页（位置 #11069-11071）的标注 | 添加于 2020年12月12日星期六 下午8:46:23\n菲利普忽然想起耶稣在临终之际的那句教诲： 宽恕他们吧，他们不知道自己做了什么。\n==========\n您在第 625 页（位置 #11082-11084）的标注 | 添加于 2020年12月12日星期六 下午8:47:12\n难道，他永远也放不下这段感情了吗？尽管发生了这么多的事，可他还是发自心底地渴望得到那个蛇蝎心肠的贱女人。这段虐恋让他遍体鳞伤，也成为他永远无法摆脱的桎梏。只有死亡才能平息对她的渴望。\n==========\n您在第 626 页（位置 #11099-11102）的标注 | 添加于 2020年12月12日星期六 下午8:48:43\n可他非但没觉得高兴，反而有些淡淡的忧伤。他的一颗心渐渐垂了下去。眼前的未来空空旷旷，冷冷凄凄。他像一个绝望的水手，在浩瀚无边的大洋上漂流多年，经历了风雨险滩，忍受了饥寒交迫，终于觅得一片平静的港口。但他正要驶入时，却刮来一阵疾风把他再一次吹进浩淼的大海。他一门心思地惦记着陆上草坪柔软、树丛茂密，而那动荡苍茫的大海却只让他苦不堪言。他不能再做一个孤零零的漂泊者了。\n==========\n您在第 626 页（位置 #11105-11107）的标注 | 添加于 2020年12月12日星期六 下午8:49:06\n他发现原来自己一直都在自欺，驱使他和萨莉结婚的念头绝不是自我牺牲，他只是想要一个妻子、一个家庭，只是想得到一份爱情罢了。可现在，这一切都将悄然从指尖溜走，他不禁陷入了深深的绝望。他对这一切的渴望超过了世上的所有。\n==========\n您在第 627 页（位置 #11111-11113）的标注 | 添加于 2020年12月12日星期六 下午8:49:35\n他的理想是什么？他曾经想看透这生活的复杂与无为，勾勒一幅精密绝伦、美不胜收的人生图案。可他从没发现也许由出生、工作、婚姻、生育、死亡编织出的最简单的形状才是最完美的模样。可能向幸福投降就是承认了生命的失败，可这样的失败却比任何勋章都更加闪亮。\n==========\n","permalink":"https://abigail1985.github.io/essay/of-human-bondage/","summary":"","title":"《人性的枷锁》书摘"},{"content":"非常喜欢阿西莫夫的《银河帝国》系列，因此听说《银河帝国》是基于吉本的《罗马帝国衰亡史》写就之后，就一直很想读一读。\n您在位置 #1463-1464的标注 | 添加于 2021年8月21日星期六 下午2:33:17\n各种宗教仪式在境内流行，对于一般民众来说，它们是同样的真实；对于哲学家来说，它们是同样的虚妄；对于地方行政官来说，则是同样的有用\n==========\n您在位置 #1476-1478的标注 | 添加于 2021年8月21日星期六 下午2:35:06\n不论是哪一种系统的神界，在发展的过程和利益的归属上都会产生对立，要依靠一位至高无上者来调停。经过长时期的教化认同和顶礼膜拜，这位神祇逐渐被提升到极度完美的崇高地位，成为“永恒的天父”和“全能的君主”。\n==========\n您在位置 #1633-1638的标注 | 添加于 2021年8月21日星期六 下午2:54:06\n但当欧洲、亚洲和非洲的主要国家都统合在一个主权的法律体系之下，从外国获得奴隶的来源日益稀少，罗马人只有换一种温和的手段和冗长的方式，即用繁殖来维持需要。很多家庭鼓励奴隶婚配生子，特别是有田产的大户更是如此。情感的作用、教育的陶冶及财富的获得，都可减轻被奴役的痛苦 [96] ，奴隶能否幸福视主人的性情和处境而定，等奴隶成为更有价值的财产后，主人必定会对其更加仁慈，不是基于畏惧心理，而是关切到自身利益\n========== 您在位置 #1651-1652的标注 | 添加于 2021年8月21日星期六 下午2:56:32\n曾经有人提案规定奴隶要穿着特殊的衣服以示区别，但是叫人担心的是，一旦奴隶知道自己有这样大的数量，可能会酿成危险。\n==========\n您在位置 #1825-1831的标注 | 添加于 2021年8月23日星期一 下午12:17:21\n罗马帝国绝大多数人民是勤勉而灵巧的劳工，从各方面尽其所能为少数富人服务。那些极少数非富即贵的宠儿，为了展示骄纵的心态，满足声色的欲望，对于他们的穿着、饮食、住所和摆设，莫不务求精美舒适、富丽堂皇。这种行为被冠以奢侈浪费的恶名，历代以来受到有道之士的严厉谴责。要是每个人只拥有生活的必需品，而能弃绝无用的冗物，将必有益于人类的德行和幸福。但是在目前这种不完美的社会状况下，奢侈固然是罪恶和愚昧的根源，但看来也是矫正贫富不均的唯一手段。勤劳的工匠和高明的艺人，虽然没有田产土地，但可以凭本事从地主手中得到一份收益。\n==========\n您在位置 #1865-1868的标注 | 添加于 2021年8月23日星期一 下午12:22:42\n那个时代的人士，要想从安逸享乐的环境中，发觉潜在的衰败腐化因素，根本是不可能的事。长久以来天下太平无事，加上统一的罗马政府，慢慢给帝国注入一种毒素，使之丧失原有的活力。人们的心智逐渐降到同一水平，天才的火花熄灭，就连尚武精神也消失无遗。\n==========\n您在位置 #1881-1884的标注 | 添加于 2021年8月23日星期一 下午12:25:02\n柏拉图、亚里士多德、芝诺和伊壁鸠鲁望重士林，执文坛之牛耳。他们创建的学派被门人弟子全盘接受，逐代流传，后生小子无法冲破这无形的藩篱，只好局限心智在前人的窠臼之内。诗人和辩士的华丽词藻，无法激起熊熊的烈火，只被人们不带丝毫感情的抄袭模仿。要是有人胆敢打破成见自立门户，就被视为背离法统和正道。\n==========\n您在位置 #2162-2163的标注 | 添加于 2021年8月25日星期三 下午6:08:18\n说得明白一点，历史往往就是人类罪恶、愚昧和灾祸的记录。\n==========\n","permalink":"https://abigail1985.github.io/essay/the-history-of-the-decline-and-fall-of-roman/","summary":"\u003cp\u003e非常喜欢阿西莫夫的《银河帝国》系列，因此听说《银河帝国》是基于吉本的《罗马帝国衰亡史》写就之后，就一直很想读一读。\u003c/p\u003e","title":"《罗马帝国衰亡史》书摘"},{"content":" God, give me grace to accept with serenity the things that cannot be changed,\nCourage to change the things which should be changed,\nand the Wisdom to distinguish the one from the other.\n 简介 本站de_AbigaÏl主要用来存放AbigaÏl的学习笔记和kindle书摘，以及大量无处释放的分享欲。\n欢迎来到我的世界！\n联络 邮箱：abigail1985@sjtu.edu.cn\n评论 评论采用：Waline\n自定义头像：Gravatar\n用户在本站发表评论后，网站会收集表格中所填写的信息，以及用户的 IP 地址和浏览器 UA(user agent)以帮助检测垃圾评论。评论元数据将会保留，用于评论的展示以及回复。\n知识共享协议 网站中出现的第三方媒体内容均基于《中华人民共和国著作权法》第二十四条，基于学习、研究、介绍、评论及说明的目的进行引用。\n所有的引用内容均为公开的互联网资源，文件来自：\n 官方网站上已公开发表的内容 官方在社交媒体上公开发表的内容 官方在第三方媒体上公开发表的内容  不会被发表、引用的内容：\n 个人反感的内容 明确禁止再发表的内容 无法经过内容审查的内容  本网站的所有原创内容（包括但不限于文字，图形图像等）均经过AbigaÏl 授权进行分发并基于 署名-非商用-相同方式共享 4.0 国际许可协议 (CC BY-NC-SA 4.0)进行共享。在遵守《中华人民共和国著作权法》，作品标注的许可协议，及相关法律的情况下，不限制对网站内作品的再发表。\n如果本网站侵犯了您的权利，请联络管理员邮箱进行协商。\n","permalink":"https://abigail1985.github.io/about/","summary":"God, give me grace to accept with serenity the things that cannot be changed,\nCourage to change the things which should be changed,\nand the Wisdom to distinguish the one from the other.\n 简介 本站de_AbigaÏl主要用来存放AbigaÏl的学习笔记和kindle书摘，以及大量无处释放的分享欲。\n欢迎来到我的世界！\n联络 邮箱：abigail1985@sjtu.edu.cn\n评论 评论采用：Waline\n自定义头像：Gravatar\n用户在本站发表评论后，网站会收集表格中所填写的信息，以及用户的 IP 地址和浏览器 UA(user agent)以帮助检测垃圾评论。评论元数据将会保留，用于评论的展示以及回复。\n知识共享协议 网站中出现的第三方媒体内容均基于《中华人民共和国著作权法》第二十四条，基于学习、研究、介绍、评论及说明的目的进行引用。\n所有的引用内容均为公开的互联网资源，文件来自：\n 官方网站上已公开发表的内容 官方在社交媒体上公开发表的内容 官方在第三方媒体上公开发表的内容  不会被发表、引用的内容：\n 个人反感的内容 明确禁止再发表的内容 无法经过内容审查的内容  本网站的所有原创内容（包括但不限于文字，图形图像等）均经过AbigaÏl 授权进行分发并基于 署名-非商用-相同方式共享 4.0 国际许可协议 (CC BY-NC-SA 4.0)进行共享。在遵守《中华人民共和国著作权法》，作品标注的许可协议，及相关法律的情况下，不限制对网站内作品的再发表。","title":"关于"},{"content":"暂时还没有友人呢～\n欢迎交换友链！\n","permalink":"https://abigail1985.github.io/friend/","summary":"暂时还没有友人呢～\n欢迎交换友链！","title":"友人"},{"content":"[TOC]\n运算符重载 运算符重载的基本概念   为什么引入运算符重载？\n在数学上，两个复数可以直接进行+、-等运算。但在C++中，直接将+或-用于复数对象是不允许的。有时会希望，让对象也能通过运算符进行运算。这样代码更简洁，容易理解。\n例如：\n complex_a和complex_b是两个复数对象；\n求两个复数的和, 希望能直接写： complex_a + complex_b\n   运算符重载是什么？\n  运算符重载，就是对已有的运算符(C++中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。\n  运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象。\n  同一个运算符，对不同类型的操作数，所发生的行为不同。\n complex_a + complex_b =新的复数对象\n5 + 4 = 9\n     运算符重载的形式？\n  本质是函数重载\n  可以重载为普通函数，也可以重载为成员函数\n  把含运算符的表达式转换成对运算符函数的调用。\n  把运算符的操作数转换成运算符函数的参数。\n  运算符被多次重载时，根据实参的类型决定调用哪个运算符函数。\n返回值类型 operator 运算符 (形参表) { ... }     例子：\nclass Complex { public: double real,imag; Complex(double r=0.0,double r=0.0):real(r),imag(i){} //上方的构造函数添加了初始化列表，将real初始化为r，将imag初始化为i，这种风格比在函数体内直接用r，i赋值的风格更好 }; //重载成普通函数，参数个数为运算符目数 Complex operator+(const Complex\u0026amp; a,const Complex\u0026amp; b) {return Complex(a.real+b.real,a.imag+b.imag);} //返回一个Complex类的临时对象  //重载成成员函数，参数个数为运算符目数-1,因为此时一个参数已经确定了，就是这个重载归属的那个类定义的对象 Complex Complex::operator-(const Complex\u0026amp; c) {return Complex(real-c.real,imag+c.imag);} //返回一个Complex类的临时对象  int main() { Complex a(4,4),b(1,1),c; c=a+b; //等价于c=operator+(a,b);  cout\u0026lt;\u0026lt;c.real\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;c.imag\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;(a-b).real\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;(a-b).imag\u0026lt;\u0026lt;endl; //a-b等价于a.operator-(b)，operator-被固定的那个变量就是对象a  return 0; } Output:\n5,5 3,3 小结：\n  重载成普通函数，参数个数为运算符目数；\n重载成成员函数，参数个数为运算符目数-1\n  c=a+b等价于c=operator+(a,b);\na-b等价于a.operator-(b)\n  赋值运算符的重载 为什么引入赋值运算符重载？ 有时候希望赋值运算符两边的类型可以不匹配\n比如，把一个int类型变量赋值给一个Complex对象， 或把一个 char * 类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“=”。\n赋值运算符”=“只能重载为成员函数\n例子\nclass String { private:char* str; public:String():str(new char[1]){str[0]=0;} //上面的构造函数添加了初始化列表，which new了一个只有一个元素的字符串数组，然后用这个数组的地址初始化str。在构造函数中往str写入一个0。最终str指向一个空字符串  const char* c_str(){return str;}; //上面的成员函数没有参数，返回一个指向常量字符串的指针，也就是str  String\u0026amp; operator=(const char* s); //将“=”重载为读取一个指向char型数据的指针，返回一个String类临时对象的引用  String::~String(){delete[]str;} //由于str指向的字符串数组是被new出来的，所以删除时必须使用delete[] }; //下面的重载是为了使得obj=\u0026#34;hello\u0026#34;能够成立 String\u0026amp; String::operator=(const char* s) { delete[]str; //先删除对象String中变量str原本指向的字符串数组  str=new char[strlen(s)+1]; //初始化str，令str指向一个new出来的字符串数组，该数组大小为“=”参数数组长度+1  strcpy(str,s); //上上句新建好str后，这句把s的内容拷贝到了str里面  return *this; //返回这个成员函数作用的对象String的引用 } int main() { String s; s=\u0026#34;Good Luck,\u0026#34;;//等价于s.operator=(\u0026#34;Good Luck,\u0026#34;);  cout\u0026lt;\u0026lt;s.c_str()\u0026lt;\u0026lt;endl; //String s2=\u0026#34;hello!\u0026#34;;  //这句话不注释掉就会出错，因为这句话不是赋值语句，而是初始化语句，会调用构造函数，但我们之前的构造函数不接受参数  s=\u0026#34;Shenzhou 8!\u0026#34;; cout\u0026lt;\u0026lt;s.c_str()\u0026lt;\u0026lt;endl; return 0; } Output:\nGood Luck, Shenzhou 8! 浅拷贝和深拷贝 class String { private:char* str; public:String():str(new char[1]){str[0]=0;} const char* c_str(){return str;}; String\u0026amp; operator=(const char* s); String::~String(){delete[]str;} }; String\u0026amp; String::operator=(const char* s) { delete[]str; str=new char[strlen(s)+1]; strcpy(str,s); return *this; } 还是这个例子，但此时我们想要实现：\n String S1，S2；\nS1=“this”；\nS2=“that”；\nS1=S2；\n 如果不改变上面的代码(也就是浅拷贝)，实际执行情况是下面这样的：\n这导致以下几种问题：\n 如不定义自己的赋值运算符，那么S1=S2实际上导致 S1.str和 S2.str 指向同一地方。原先S1指向的地方无法删除被浪费掉。 如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还 要释放一次，但一片被new出来的空间只能被delete一次。 另外，如果执行 S1 = \u0026ldquo;other\u0026rdquo;；会导致S2.str指向的地方被delete  因此要在 class String里添加成员函数:\nString\u0026amp; operator=(const String\u0026amp; s) { delete[]str; str=new char[strlen(s.str)+1]; strcpy(str,s.str); return *this; } 但是这样还不够，考虑下面的语句\n String s;\ns = \u0026ldquo;Hello\u0026rdquo;;\ns = s;\n 如果等号两边的对象一样，=应该什么都不做。所以重载“=”应为：\nString\u0026amp; operator=(const String\u0026amp; s) { if(this==\u0026amp;s) return *this； delete[]str; str=new char[strlen(s.str)+1]; strcpy(str,s.str); return *this; } 上面的重载即实现了深拷贝。\n扩展：https://www.zhihu.com/question/36370072/answer/67181275\n 那么如果原来的物体销毁了，但是现在拷贝的物体还在，那么这时候你拷贝后的物体的成员指针就是一个悬挂指针，指向了不再存在的物体，那么你访问的话，那就不知道会发生什么了。\n而对于深拷贝，这一个勤奋的人，他不会只做表面，他会把每一个细节都照顾好。于是，当他遇到指针的时候，他会知道new出来一块新的内存，然后把原来指针指向的值拿过来，这样才是真正的完成了克隆体和原来的物体的完美分离，如果物体比作人的话，那么原来的人的每一根毛细血管都被完美的拷贝了过来，而绝非只是表面。所以，这样的代价会比浅拷贝耗费的精力更大，付出的努力更多，但是是值得的。当原来的物体销毁后，克隆体也可以活的很好。\n 对operator=返回值的讨论 对运算符进行重载的时候，好的风格应该尽量保留运算符原本的特性\n  返回值为什么不能是void？\na=b=c等价于a.operator=(b.operator=(c))\n若b.operator=(c)返回值为void，则a=void，不可\n  返回值为什么不能是String？\n(a=b)=c等价于(a.operator=(b)).operator=(c)\n若a.operator=(b)返回值是a，下一步就会让a=c的值。也就是这句话先让a=b的值，再让a=c的值，最终b并没有等于a和c，不可\n  复制构造函数的相同困境 为 String类编写复制构造函数的时候，会面临和 = 同样的问 题，用同样的方法处理。\nString( String \u0026amp; s) { str = new char[strlen(s.str)+1]; strcpy(str,s.str); } 运算符重载为友元函数   为什么要将运算符重载为友元？\n有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。\n例子：\nclass Complex { double real,imag; public: Complex( double r, double i):real(r),imag(i){ }; Complex operator+( double r ); }; Complex Complex::operator+( double r ) { //能解释 c+5  return Complex(real + r,imag); } 经过上述重载后：\n Complex c ;\nc = c + 5; //有定义，相当于 c = c.operator +(5);\nc = 5 + c; //编译出错\n 所以，为了使得上述的表达式能成立，需要将 + 重载为普通函数。\nComplex operator+ (double r,const Complex \u0026amp; c) { //能解释 5+c  return Complex( c.real + r, c.imag); } 但是普通函数又不能访问私有成员，所以，需要将运算符 + 重载为友元。\nclass Complex { double real,imag; public: Complex( double r, double i):real(r),imag(i){ }; Complex operator+( double r ); friend Complex operator + (double r,const Complex \u0026amp; c); };   实例：可变长数组的实现 要编写可变长整型数组类，使之能如下使用\nint main() { CArray a;//开始时数组是空的  for(int i=0;i\u0026lt;5;++i) a.push_back(i); //❗要用动态分配的内存来存放数组元素，需要一个指针成员变量  CArray a2,a3; a2=a; //❗要重载“=”  for(int i=0;i\u0026lt;a.length();++i) cout\u0026lt;\u0026lt;a2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //❗要重载中括号[]  a2=a3;//a2变成空的  for(int i=0;i\u0026lt;a2.length();++i)//此时a2.length返回0  cout\u0026lt;\u0026lt;a2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; a[3]=100;//将数组a的第三个数改为100  CArray a4(a); //❗要自己写一个复制构造函数，不能用缺省的  for(int i=0;i\u0026lt;a4.length();++i) cout\u0026lt;\u0026lt;a4[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; return 0; } Output:\n0 1 2 3 4 0 1 2 100 4 该怎么写这个数组类？？\nclass CArray { int size;//数组元素的个数  int* ptr;//指向动态分配的数组  public CArray(int s=0);//构造函数，s代表数组元素的个数  CArray(CArray\u0026amp; a);//复制构造函数  ~CArray();//析构函数  void push_back(int v);//用于在数组尾部添加一个元素v  CArray\u0026amp; operator=(const CArray\u0026amp; a);//用于数组对象间的赋值  int length(){return size;}//返回数组元素个数  int\u0026amp; CArray::operator[](int i){return ptr[i];} //用于支持根据下标访问数组元素，如n=a[i]和a[i]=4这样的语句  //❗❗❗对于返回值的解释，看下面解释 } 对于int\u0026amp; CArray::operator[](int i){return ptr[i];}要注意：\n返回值类型必须是int\u0026amp;，不能是int！！！这是因为如果一个函数的返回值不是引用，不能将它写在等号左边，所以a[i]=4这句话将编译出错\n/**********************构造函数**********************************/ CArray::CArray(int s):size(s) //这个初始化列表用s初始化size，s的缺省值是0(即不给参数时使用的s值) { if(s==0) ptr=NULL; else ptr=new int[s]; } /**********************复制构造函数*******************************/ CArray::CArray(CArray\u0026amp; a) { //如果a.ptr指向空数组，就令ptr指向空数组  if(!a.ptr){ ptr=NULL; size=0; return; } //如果a.ptr指向非空数组，就创建一个同样大小的空间复制上a.ptr的内容并将地址赋给ptr  ptr=new int[a.size]; memcpy(ptr,a.ptr,sizeof(int)*a.size); size=a.size; }//上面这个复制构造函数完成了深拷贝的工作  /**********************析构函数**********************************/ CArray::~CArray() { if(ptr) delete[]ptr; } /**********************“=”的重载函数*****************************/ //赋值号的作用是使“=”左边对象里存放的数组，大小和内容都和右边的对象一样 CArray\u0026amp; CArray::operator=(const CArray\u0026amp; a) { if(ptr==a.ptr)//防止a=a这样的赋值出错  return *this; if(a.ptr==NULL){//如果a里面的数组是空的  if(ptr)//如果ptr指向的数组不是空的  delete[]ptr; ptr=NULL; size=0; return *this; } if(size\u0026lt;a.size){//如果原有空间不够用，就需要分配新的空间  if(ptr) delete[]ptr; ptr=new int[a.size]; } memcpy(ptr,a.ptr,sizeof(int)*a.size); //如果原有空间够大，就不分配新的空间  size=a.size; return *this; } /**********************push_back函数*****************************/ void CArrary::push_back(int v) { /*下面做分配空间的工作*/ if(ptr){//原数组不空  int* tmpPtr=new int[size+1];//创造一个比原数组多一个空间的数组  memcpy(tmpPtr,ptr,sizeof(int)*size);//拷贝原数组到tmpPtr里  delete[]ptr;//原数组被复制好后就可以删除释放空间  ptr=tmpPtr;//现在的ptr指向的空间比原来的大1  } else//原数组是空的  ptr=new int[1]; /*下面做加入新的数组元素的工作*/ ptr[size++]=v; } 流插入运算符和流提取运算符的重载 流插入运算符(左移运算符)：\u0026laquo; cout是在iostream中定义的，ostream类的对象。“\u0026laquo;”能用在cout上是因为再iostream中对“\u0026laquo;”进行了重载。\n  ostream类中对\u0026laquo;的重载（头文件中别人已经写好的代码）\n 考虑怎么重载才能使得下列语句成立：\n  cout\u0026laquo;5;\ncout\u0026laquo;\u0026ldquo;this\u0026rdquo;;\ncout\u0026laquo;5\u0026laquo;\u0026ldquo;this\u0026rdquo;;\n 按照以下方式重载成ostream类的成员函数，返回值是ostream类的引用\nostream\u0026amp; ostream::operator\u0026lt;\u0026lt;(int n) { ...//输出n的代码  return *this； } ostream\u0026amp; ostream::operator\u0026lt;\u0026lt;(const char* s) { ...//输出s的代码  return *this； } cout\u0026lt;\u0026lt;5\u0026lt;\u0026lt;\u0026quot;this\u0026quot;等价于cout.operator\u0026lt;\u0026lt;(5).operator\u0026lt;\u0026lt;(\u0026quot;this\u0026quot;)\n  将\u0026laquo;重载为全局函数(需要自己写的）\n 假定下面程序输出为5hello，我们该如何补写？\nclass CStudent{ public:int nAge; }; int main() { CStudent s ; s.nAge = 5; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt;\u0026#34;hello\u0026#34;; return 0; }  ostream\u0026amp; ostream\u0026lt;\u0026lt;(ostream\u0026amp; o,const CStudent\u0026amp; s) { o\u0026lt;\u0026lt;s.nAge; return o; } 正如：\n 重载成普通函数，参数个数为运算符目数；\n重载成成员函数，参数个数为运算符目数-1\n \u0026laquo;被重载成全局函数，第一个参数就是cout，因此第一个参数类型必须为ostream或ostream\u0026amp;\n由于我们需要继续输出“hello”，因此返回值必须为cout，故返回值类型为ostream\u0026amp;\n  将\u0026laquo;重载为全局函数，且定义成相关类的友元函数（需要自己写的）\n这样可以访问指定类的私有成员\n 假定c是Complex复数类的对象，现在希望 写cout \u0026lt;\u0026lt; c;，就能以a+bi的形 式输出c的值，写cin\u0026gt;\u0026gt;c;，就能从键 盘接受a+bi形式的输入，并且使得 c.real = a,c.imag = b\nint main() { Complex c; int n; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;n; cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;n; return 0; } 示例输入/输出\ninput:13.2+133i 87 output:13.2+133i,87  我们编写Complex类如下：\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;cstdlib\u0026gt;using namespace std; class Complex{ double real,imag; public: Complex(double r=0,double i=0):real(r),imag(i){}; friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os,const Complex\u0026amp; c); friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is,const Complex\u0026amp; c); //上面语句将\u0026lt;\u0026lt;,\u0026gt;\u0026gt;重载为Complex类的友元，可以访问Complex类的私有成员real，imag }; /****************对\u0026lt;\u0026lt;的重载***********************************/ ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os,Complex\u0026amp; c) { os\u0026lt;\u0026lt;c.real\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;c.imag\u0026lt;\u0026lt;\u0026#34;i\u0026#34;;//以“a+bi”的形式输出  return os; } /****************对\u0026gt;\u0026gt;的重载***********************************/ istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; is,Complex\u0026amp; c) { //将“a+bi”作为字符串读入，“a+bi”中间不能有空格  string s; is\u0026gt;\u0026gt;s; //确定实部和虚部的分界点  int pos=s.find(\u0026#34;+\u0026#34;,0); //分离出代表实部的字符串  string sTmp=s.substr(0,pos); c.real=atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成float  //分离出代表虚部的字符串  sTmp=s.substr(pos+1,s.length()-pos-2); c.imag=atof(sTmp.c_str()); return is; } ❗❗❗c_str()：\n该函数返回一个指向正规C字符串的指针常量, 内容与本string串相同。 这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串\n  类型转换运算符的重载 #include\u0026lt;iostream\u0026gt;using namespace std; class Complex { double real,imag; public: Complex(double r=0,double i=0):real(r),imag(i){}; operator double(){return real;} //重载了 强制类型转换运算符 double }; int main() { Complex c(1.2,3.4); /*显式转换*/ cout\u0026lt;\u0026lt;(double)c\u0026lt;\u0026lt;endl;//输出1.2  /*隐式转换*/ double n=2+c;//等价于double n=2+c.operator double()  cout\u0026lt;\u0026lt;n;//输出3.2 } 自增自减运算符的重载   如何将前置/后置的++，\u0026ndash;区分开？\n自增运算符++、自减运算符\u0026ndash;有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，C++规定：\n  前置运算符作为一元运算符重载\n  重载为成员函数\nT\u0026amp; operator++() T\u0026amp; operator--()   重载为全局函数\nT1\u0026amp; operator++(T2); T1\u0026amp; operator--(T2); //重载为全局函数时需要的参数个数比成员函数时多一个     后置运算符作为二元运算符重载,要多写一个没用的参数\n  重载为成员函数\nT operator++(int); T operator--(int);   重载为全局函数\nT1 operator++(int,T2); T1 operator--(int,T2); //重载为全局函数时需要的参数个数比成员函数时多一个       重载运算符的返回值\n 重载的原则:对运算符的重载要尽量维持运算符原本的属性 c++中内置的++a返回值是a的引用, a++返回值是临时变量a 这也是为什么可以有(++a)=1,但不能有(a++)=1,(函数的返回值如果不是引用,不能放在等好的左边) 为了维持上面那种性质,前置运算符的返回值是对象,后置运算符的返回值是临时变量    例子:\nint main() { CDemo d(5); cout\u0026lt;\u0026lt;(d++)\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;d\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;(++d)\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;d\u0026lt;\u0026lt;\u0026#34;endl\u0026#34;; cout\u0026lt;\u0026lt;(d--)\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;d\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;(++d)\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;d\u0026lt;\u0026lt;\u0026#34;endl\u0026#34;; return 0; } 要求输出结果为\n 5,6,7,7 7,6,5,5\n 该如何编写CDemo?\nclass Demo { private: int n; public: CDemo(int i=0):n(i){}//初始化列表用i初始化n  operator int(){return n;}s.int() //强制类型转换运算符的重载,使得(int)s等价于s.int()  //类型强制转换运算符重载时不能写返回值类型,实际上其返回值类型就是该运算符代表的类型  CDemo\u0026amp; operator++();//前置成员  CDemo operator++(int)//后置成员  friend CDemo\u0026amp; operator--(CDemo\u0026amp;);//前置全局  friend CDemo operator--(CDemo\u0026amp;,int);//后置全局 }; /*************************++a重载为成员函数*********************************/ CDemo\u0026amp; CDemo::operator++() { n++;//这个n是operator++()作用的那个对象的私有变量n  return *this;//返回修改后的对象的引用 } //++s等价于s.operator++()  /*************************a++重载为成员函数*********************************/ CDemo CDemo::operator++(int k)//k是一个没用的参数 { CDemo tmp(*this);//用复制构造函数构造一个临时对象,将修改前的对象的n值赋给他  n++; return tmp;//返回修改前的对象 }//s++等价于s.operator++(0)  /*************************--a重载为全局函数*********************************/ CDemo\u0026amp; operator--(CDemo\u0026amp; d)//对一个全局函数,传进来的参数必须是引用才能修改他的值 { d.n++; return d; }//--s等价于operator--(s)  /*************************a--重载为全局函数*********************************/ CDemo operator--(CDemo\u0026amp; d) { CDemo tmp(d); n++; return tmp; }//s--等价于operator--(s,0) 注意事项  C++不允许定义新的运算符 ； 重载后运算符的含义应该符合日常习惯:  complex_a + complex_b word_a \u0026gt; word_b date_b = date_a + n   运算符重载不改变运算符的优先级； 以下运算符不能被重载：“.”、“.*”、“::”、“?:”、sizeof； 重载运算符()、[]、-\u0026gt;或者赋值运算符=时，运算符重载函数必须声明为 类的成员函数。  继承   继承:\n 在定义一个新的类B时,如果该类与某个已有的类A相似(指的是B拥有A的全部特点),那么可以把A作为一个基类而把B作为基类的一个派生类  这是为了避免重复定义相似的类的麻烦\n  派生类的性质:\n  派生类中可以添加新的成员变量和成员函数\n  派生类一经定义可以独立使用\n  派生类拥有基类的全部成员**(但是依旧不能访问private)**\n    例子-学生管理系统\nclass CStudent{ private: string sName; int nAge; public: bool IsThreeGood(){}; void SetName(const string \u0026amp;name)//\u0026amp;表示引用  {sName=name;} }; //派生类的写法:类名:public基类名 class CundergraduateStudent:public CStudent{ private: int nDepartement; public: bool IsThreeGood(){...};//这个新的成员函数将基类的覆盖了  bool CanBaoYan(){...}; }; class CGraduatedStudent:public CStudent{ private: int nDepartement; char szMentorName[20]; public: int CountSalary(){...}; };   派生类对象的内存空间:\n派生类对象体积=基类对象体积+派生类对象自己的成员变量体积\n基类对象的存储位置位于派生类对象新增成员变量之前\nclass CBase{ int v1,v2; }; class CDerived:public CBase{ int v3; } //CDerived体积为12个字节   继承示例程序:学籍管理\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt; using namespace std; class CStudent{ private: string name; string id; char gender; int age; public: void PrintInfo(); void Setnfo(const string \u0026amp; name_,const string \u0026amp; id_,int age_.char gender_); //\u0026amp;参数是引用  string GetName(){return name;} }; class CUndergraduateStudent:public CStudent{ private: string department; public: void QualifiedForBaoyan(){ cout\u0026lt;\u0026lt;\u0026#34;qualified for baoyan\u0026#34;\u0026lt;\u0026lt;endl; } //PrintInfo对于基类的同名函数是覆盖的关系  void PrintInfo(){ CStudent::PrintInfo();//调用基类的  cout\u0026lt;\u0026lt;\u0026#34;Department:\u0026#34;\u0026lt;\u0026lt;departement\u0026lt;\u0026lt;endl; void SetInfo(const string\u0026amp; name_,const string\u0026amp; id_,int age_,char gender_,const string\u0026amp; department_){ CStudent::SetInfo(name_,id_,age_,gender_);//调用基类的  department=department_; } } };   继承关系和复合关系   继承:\u0026quot;是\u0026ldquo;关系\nA是基类,B是A的派生类\n逻辑上要求:一个B对象也是一个A对象\n  复合:\u0026quot;有\u0026ldquo;关系\n逻辑上要求:A对象是B对象的成员变量\n例子:几何形体程序中,需要写\u0026quot;点\u0026quot;类,也需要写\u0026quot;圆\u0026quot;类,两者的关系就是复合关系,每一个圆对象内都包含有一个点对象,这个点对象就是圆心\n  class CPoint{ double x,y; friend class CCircle; //便于CCircle类操作其圆心 }; class CCircle{ double r; CPoint center; };   复合关系的使用\n如果要写一个小区养狗管理程序， 需要写一个“业主”类，还需要写一个“狗”类。 而狗是有 “主人” 的，主人当然是业主(假定狗只有 一个主人，但一个业主可以有最多10条狗）\n    凑合的写法\n//为狗类设一个业主类的对象指针 //为业主类设一个狗类的对象数组  class CMaster; //CMaster必须提前声明,不能先写CMaster再写CDog类  class CDog{ CMaster* pm; }; class CMaster{ CDog dogs[10]; }; /*这种写法的缺陷: 1.对象的成员变量理论上应是该对象的不可分割的组成部分,但主人对于狗并不是这种关系 2.所有的狗对象都被放在一个数组中,对狗的操作必须通过主人来进行   正确的写法\n//为狗类设一个业主类对象指针 //为业主类设一个狗类对象指针数组  class CMaster; class CDog{ CMaster* pm; }; class CMaster{ CDog* dogs[10] };   覆盖和保护成员 覆盖\n派生类可以定义一个和基类成员同名的成员,这叫做覆盖\n在派生类中访问这类成员时,缺省的情况是访问派生类中定义的成员\n要在派生类中访问由基类定义的同名成员时,要使用作用域符号::\n类的保护成员\n  基类的private成员：可以被下列函数访问\n– 基类的成员函数\n– 基类的友元函数\n  基类的public成员：可以被下列函数访问\n– 基类的成员函数\n– 基类的友元函数\n– 派生类的成员函数\n– 派生类的友元函数\n– 其他的函数\n  基类的protected成员：可以被下列函数访问\n– 基类的成员函数\n– 基类的友元函数\n– 派生类的成员函数可以访问当前对象的基类的保护成员\n  派生类的构造函数 class Bug{ private: int nlegs; int ncolor; public: int ntype; Bug(int legs,int color); void PrintBug(){}; }; class FlyBug:public Bug{ private: int nwings; public: FlyBugs(int legs,int color,int wings); } Bug::Bug(int legs,int color) { nlegs=legs; ncolor=color; } 错误的FlyBug构造函数写法:\nFlyBug::FlyBug(int legs,int color,int wings) { nlegs=legs;//不能访问  ncolor=color;//不能访问  //上面的操作是错误的!!!!nlegs,ncolor是基类的私有成员,不能被派生类的成员函数访问!  ntypes=1;//okk  nwings=wings; } 正确的FlyBug构造函数写法:\nFlyBug::FlyBug(int legs,int color,int wings):Bug(legs,color) //初始化列表 { nlegs=legs; ncolor=color; //上面的操作是错误的!!!!nlegs,ncolor是基类的私有成员,不能被派生类的成员函数访问!  nwings=wings; };   在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数 之前，总是先执行基类的构造函数。\n  调用基类构造函数的两种方式\n  显式方式：在派生类的构造函数中，为基类的构造函数提供参数.\nderived::derived(arg_derived-list):base(arg_base-list)\n  隐式方式：在派生类的构造函数中，省略基类构造函数时， 派生类的构造函数则自动调用基类的默认构造函数.\n    派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。\n  公有继承的赋值兼容规则 公有继承:class derived: public base{ };\nclass base{}; class derived:public base{}; base b; derived d; 规则:\n  派生类的对象可以赋值给基类对象\nb=d;   派生类对象可以初始化基类的引用\nbase \u0026amp; br=d;   派生类对象的地址可以赋值给基类指针\nbase * pb=\u0026amp;d;   直接基类和间接基类:\n  声明派生类时,只需要列出其直接基类\n  派生类沿着类的层次向上自动继承他的间接基类\n  派生类的成员包括:\n  直接基类的成员\n  所有间接基类的所有成员\n  自己的成员\n    #include\u0026lt;iostream\u0026gt;using namespace std; class base{ public: int n; base(int i):n(i){ //构造函数有参数,也有初始化列表  //n是成员变量,i是参数表  cout\u0026lt;\u0026lt;\u0026#34;base\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34;constructed\u0026#34;\u0026lt;\u0026lt;endl; } ~base(){ cout\u0026lt;\u0026lt;\u0026#34;base\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34;destructed\u0026#34;\u0026lt;\u0026lt;endl; } }; class derived:public base{ public: derived(int i):base(i){ //构造函数有参数,也有初始化列表  cout\u0026lt;\u0026lt;\u0026#34;derived constructed\u0026#34;\u0026lt;\u0026lt;endl; } ~derived(){ cout\u0026lt;\u0026lt;\u0026#34;derived destructed\u0026#34;\u0026lt;\u0026lt;endl; } }; class morederived:public derived{ public: morederived():derived(4){ //构造函数有参数,也有初始化列表  //只需要直接基类的初始化列表  cout\u0026lt;\u0026lt;\u0026#34;morederived constructed\u0026#34;\u0026lt;\u0026lt;endl; } ~morederived(){ cout\u0026lt;\u0026lt;\u0026#34;morederived destructed\u0026#34;\u0026lt;\u0026lt;endl; } }; int main() { morederived obj; return 0; } output:\nbase4constructed derived constructed morederived constructed morederived destructed derived destructed base4destructed 多态 虚函数和多态   虚函数\n在类的定义中,前面有virtual关键字的成员函数\nclass base{ virtual int get(); }; ❗❗virtual关键字只用在类定义里的函数声明中,写函数体时候不用\nint base::get()//不需要在get前面加virtual!!! ❗❗构造函数和静态成员函数不能是虚函数\n❗❗虚函数和普通函数的本质差别:虚函数可以参与多态,静态函数不能\n  多态的表现形式一:指针\n  派生类的对象可以赋给基类指针\n  通过基类指针调用基类和派生类中的同名虚函数时候:\n  若指针指向一个基类的对象,则被调用的是基类的虚函数\n  若指针指向一个派生类的对象,则被调用的是派生类的虚函数\n    class Cbase(){ public: virtual void SomeVirtualFunction(){} }; class Cderived:public Cbase(){ public: virtual void SomeVirtualFunction(){} }; int main(){ Cderived Oderived; Cbase *p= \u0026amp;Oderived; p-\u0026gt;SomeVirtualFunction(); //p指向派生类的对象,调用的是派生类的虚函数  return 0; }   多态的表现形式二:对象\n 派生类的对象可以赋给基类引用 通过基类引用调用基类和派生类中的同名虚函数时:  若该引用引得是一个基类的对象,那么被调用的是基类的虚函数 若该引用引得是一个派生类的对象,那么被调用的是派生类的虚函数      class Cbase(){ public: virtual void SomeVirtualFunction(){} }; class Cderived(){ public: virtual void SomeVirtualFunction(){} }; int main(){ Cderived Oderived; Cbase \u0026amp;r=Oderived; r.SomeVirtualFunction();//!!!引用调用函数时用\u0026#34;.\u0026#34;!!!  //r引用的是派生类的对象,调用派生类的虚函数 }   多态的作用\n增强程序的可扩充性**(程序需要修改或增加功能的时候,需要改动和增加的代码较少)**\n  使用多态的游戏程序示例 几何形体处理程序 #include\u0026lt;iostream\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#include\u0026lt;math.h\u0026gt; using namespace std; //定义基类 class CShape{ public: virtual double Area()=0; //后面写了一个\u0026#34;=0\u0026#34;,说明这是纯虚函数,连函数体都没有  virtual void PrintInfo()=0; //因为我们要处理的图形只有圆形三角矩形几种,不存在CShape这样一种抽象的形状,所以不需要为CShape编写这两程序,这两程序在派生类中会分别定义 }; //定义派生类 class CRectangle:public CShape{ public: int w,h; virtual double Area(); virtual void PrintInfo(); }; class CCircle:public CShape{ public: int r; virtual double Area(); virtual void PrintInfo(); }; class CTriangle:public CShape{ public: int a,b,c; virtual double Area(); virtual void PrintInfo(); }; //实现派生类的成员函数  double CRectangle::Area(){ return w*h; } void CRectangle::PrintInfo(){ cout\u0026lt;\u0026lt;\u0026#34;Rectangle:\u0026#34;\u0026lt;\u0026lt;Area()\u0026lt;\u0026lt;endl;//输出的末尾要加endl!! } double CCircle::Area(){ return 3.14*r*r; } void CCircle::PrintInfo(){ cout\u0026lt;\u0026lt;\u0026#34;Circle:\u0026#34;\u0026lt;\u0026lt;Area()\u0026lt;\u0026lt;endl; } double CTriangle::Area(){ double p=(a+b+c)/2.0; return sqrt(p*(p-a)*(p-b)*(p-c)); } void CCircle::PrintInfo(){ cout\u0026lt;\u0026lt;\u0026#34;Triangle:\u0026#34;\u0026lt;\u0026lt;Area()\u0026lt;\u0026lt;endl; } //存放不同类型的几何形体 CShape *pShapes[100]; int MyCompare(const void *s1,const void *s2); //用三个数组来存浪费空间,难以增改,难以实现排序等进阶功能 //所以我们使用多态来存储 //pShapes数组中的元素都是基类指针,由于基类指针能够指向派生类对象,我们可以在后面把指针指向new出来的派生类对象  //主函数 int main(){ int i;int n; CRectangle *pr;CCircle *pc;CTriangle *pt; cin\u0026gt;\u0026gt;n; for(i=0;i\u0026lt;n;i++){ char c; cin\u0026gt;\u0026gt;c; switch(c){ case\u0026#39;R\u0026#39;: pr=new CRectangle(); cin\u0026gt;\u0026gt;pr-\u0026gt;w\u0026gt;\u0026gt;pr-\u0026gt;h; pShapes[i]=pr; break; case \u0026#39;C\u0026#39;: pc=new CCircle(); cin\u0026gt;\u0026gt;pc-\u0026gt;r; pShapes[i]=pc; break; case\u0026#39;T\u0026#39;: pt=new CTriangle(); cin\u0026gt;\u0026gt;pt-\u0026gt;a\u0026gt;\u0026gt;pt-\u0026gt;b\u0026gt;\u0026gt;pt-\u0026gt;c; pShapes[i]=pt; break; } } qsort(pShapes,n,sizeof(CShape*),MyCompare); for(i=0;i\u0026lt;n;i++) pShapes[i]-\u0026gt;PrintInfo(); return 0; } //为什么变量前面要加关键字void*?然后可以将指向任何类型数据的指针赋给这个void*类型指针 int MyCompare(const void *s1,const void *s2){ double a1,a2; CShape**p1; CShape**p2; //一定要写两个*,不能用\u0026#34;*s1\u0026#34;来取得s1指向的内容  p1=(CShape**)s1; p2=(CShape**)s2; //s1,s2指向数组中的元素,数组中元素的类型是CShape*  //因此p1,p2是指向指针的指针,类型为CShape**  a1=(*p1)-\u0026gt;Area();//*p1的类型是CShape*是基类指针  a2=(*p2)-\u0026gt;Area(); if(a1\u0026lt;a2) return -1; else if(a2\u0026lt;a1) return 1; else return 0; } *下面是 qsort() 函数的声明。\nvoid qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))  base \u0026ndash; 指向要排序的数组的第一个元素的指针。 nitems \u0026ndash; 由 base 指向的数组中元素的个数。 size \u0026ndash; 数组中每个元素的大小，以字节为单位。 compar \u0026ndash; 用来比较两个元素的函数。  虚析构函数,纯虚函数,抽象类 虚析构函数:\nclass son{ public: ~son(){cout\u0026lt;\u0026lt;\u0026#34;bye from son\u0026#34;\u0026lt;\u0026lt;endl;} }; class grandson:public son{ public: ~grandson(){cout\u0026lt;\u0026lt;\u0026#34;bye from grandson\u0026#34;\u0026lt;\u0026lt;endl;} }; int main() { son *pson; pson=new grandson(); //new一个对象的时候,如果对象的构造函数不需要参数就要写一对括号,跟new一个数据不一样  delete pson; return 0; } output:\nbye from son new出来的grandson没有被删除!!!!!,反而执行了son的析构函数,然而我们并没有定义son类的对象\n解决办法:\n把基类son的析构函数变成虚函数\n纯虚函数和抽象类:\n  包含纯虚函数的类就是抽象类\n  抽象类不能创建自己的对象\n  抽象类的指针/引用可以指向其派生类的对象\n  在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部 不能调用纯虚函数。\n  如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。\n  输入输出和模板 函数模板  例子-求数组最大元素的函数模板  template\u0026lt;class T\u0026gt; T MaxElement(T a[],int size){ T tmpMax=a[0]; for(int i=1;i\u0026lt;size;i++) if(tmpMax\u0026lt;a[i]) tmpMax=a[i] return tmpMax; }  例子-不通过参数实例化函数模板  #include\u0026lt;iostream\u0026gt;using namespace std; template\u0026lt;class T\u0026gt; T Inc(T n){ return 1+T; //由于Inc的返回值是T类型的,这里要对+进行重载 } int main(){ cout\u0026lt;\u0026lt;Inc\u0026lt;double\u0026gt;(4)/2; //用\u0026lt;double\u0026gt;直接规定T是double类型 }   函数模板是可以重载的,只要他们的形参表和类型参数表不一样即可\n  函数模板和函数的次序:\n参数匹配+普通函数\u0026mdash;\u0026ndash;\u0026gt;参数匹配模板函数\u0026mdash;\u0026ndash;\u0026gt;参数经自动类型转换后能匹配的普通函数\n  类模板 编写模板是为了实现泛型程序设计,即写出一个类/函数后,可以作用与多种数据类型\n类模板的定义\ntemplate\u0026lt;typename 类型参数,typename 类型参数,...\u0026gt; class 模板名字 { 成员变量; 成员函数; } 类模板内成员函数定义\ntemplate\u0026lt;typename 类型参数,typename 类型参数,...\u0026gt; (返回值)类型参数 模板名字 \u0026lt;类型参数名字,类型参数名字,...\u0026gt;::成员函数名字(参数表) { ... } 类模板定义对象的写法\n模板名字\u0026lt;实际类型参数表\u0026gt; 对象名(构造函数实参表); 示例:Pair类模板\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string.h\u0026gt;using namespace std; //类型参数就是这个类需要的参数的类型 //其个数就该类需要的参数个数 template\u0026lt;typename T1,typename T2\u0026gt; class Pair { public: T1 key;//关键字  T2 value;//值  Pair(T1 k,T2 v):key(k),value(v){}; //构造函数及其初始化列表  bool operator \u0026lt; (const Pair\u0026lt;T1,T2\u0026gt;\u0026amp;p)const; //对\u0026#34;\u0026lt;\u0026#34;进行重载,其形参是pair模板定义的类的常引用  //我们希望这个\u0026#34;\u0026lt;\u0026#34;是不变的,最后加个const }; template\u0026lt;typename T1,typename T2\u0026gt; bool Pair\u0026lt;T1,T2\u0026gt;::operator \u0026lt; (const Pair\u0026lt;T1,T2\u0026gt;\u0026amp;p)const { return key\u0026lt;p.key; } int main() { Pair\u0026lt;string,int\u0026gt; student(\u0026#34;Tom\u0026#34;,19); //对象的名字是:student  //注意:由类模板\u0026#34;pair\u0026#34;生成类\u0026#34;pair\u0026lt;string,int\u0026gt;\u0026#34;,再由这个类生成对象\u0026#34;student\u0026#34;  cout\u0026lt;\u0026lt;student.key\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;student.value; return 0; } output:\nTom 19   类模板的实例化:编译器由类模板生成类的过程\n  同一个模板实例化出的类是不兼容的,他们根本就是两个类\nPair\u0026lt;string,int\u0026gt; *p; Pair\u0026lt;string,double\u0026gt; a; p=a;//报错   函数模板作为类模板成员\n#include\u0026lt;iostream\u0026gt;using namespace std; template\u0026lt;typename T\u0026gt; class A { public: //注意这里不能写T,因为这里成员函数的类型参数相对类的类型参数来说是形参  template\u0026lt;typename T2\u0026gt; void Func(T2 t){cout\u0026lt;\u0026lt;t;} }; int main() { A\u0026lt;int\u0026gt; a; //类模板名: A  //类名: A\u0026lt;int\u0026gt;  //对象名: a,其需要的参数类型为int(虽然下面的定义里我没有用这个参数)  a.Func(\u0026#39;K\u0026#39;);//成员函数模板Func被实例化,其参数类型为char  a.Func(\u0026#34;hello\u0026#34;);//成员函数模板Func再次被实例化,其参数类型为const char*  return 0; } output:\nKhello   A\u0026lt;int\u0026gt;这个类通过上面对函数模板Func的两次实例化有了两个名为Func的成员函数:\nFunc(char c);//赋给该函数的值是:K Func(const char* string);//赋给该函数的值是:指向字符串\u0026#34;hello\u0026#34;的指针   类模板的类型参数表中可以出现非类型参数:\n![image-20210308125420974](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210308125420974.png)\n标准模板库STL 概述 ![image-20210318145751989](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210318145751989.png)\n迭代器   用于指向顺序容器/关联容器中的元素\n  用法和指针类似\n  有const和非const两种\n  通过迭代器可以读取其指向的元素\n  通过非const迭代器可以修改其指向的元素\n  代码:\n定义一个容器类的迭代器的方法:\n容器类名::iterator 变量名; 容器类名::const_iterator 变量名; 访问一个迭代器指向的元素:\n*迭代器变量名 迭代器示例:\n#include\u0026lt;vector\u0026gt;#include\u0026lt;iostream\u0026gt;using namespace std; int main() { vector\u0026lt;int\u0026gt; v; //v是一个存放int类型元素的动态数组,一开始里面没有元素  v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); //正向迭代器  vector\u0026lt;int\u0026gt;::const_iterator i; //常量迭代器,只能读取元素,不能修改元素  for(i=v.begin();i!=v.end();i++) //begin()获取容器第一个元素的位置  //end()获取容器最后一个元素后面的位置  cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;endl; //反向迭代器  vector\u0026lt;int\u0026gt;::reverse_iterator r; for(r=v.rbegin();r!=v.rend;r++) //rbegin()获取容器最后一个元素的位置  //rend()获取容器第一个元素前面的位置  cout\u0026lt;\u0026lt;*r\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; cout\u0026lt;\u0026lt;endl; //非常量迭代器  vector\u0026lt;int\u0026gt;::iterator j; for(j=v.begin();j!=v.end();j++) *j=100;//用非常量迭代器修改指向的元素  for(i=v.begin();i!=v.end();i++) cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;\u0026#34;,\u0026#34;;//用常量迭代器读取指向的元素  cout\u0026lt;\u0026lt;endl; } 两种不同的的迭代器：\n  双向迭代器p\u0026amp;p1\n  ++p，p++\n  \u0026ndash;p，p\u0026ndash;\n  p*（实际上返回值是p指向的对象的引用）**\n  p=p1\n  p==p1；p！=p1\n    随即访问迭代器p\u0026amp;p1\n 双向迭代器的所有操作 p+=i（将p向后移动i个元素） p-=i p+i （p+i的值=指向p后面第i个元素的迭代器） p-i p[i]（p[i]的值=p后面第i个元素的引用） p\u0026lt;p1;p\u0026lt;=p1;p\u0026gt;p1;p\u0026gt;=p1    容器 顺序容器 vector(动态数组) vector上的操作\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;using namespace std; template\u0026lt;class T\u0026gt; void PrintVector(T s,T e) { for(;s!=e;++s) cout\u0026lt;\u0026lt;*s\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } int main() { int a[5]={1,2,3,4,5}; vector\u0026lt;int\u0026gt; v(a,a+5); //将数组a中下标从0到4的元素都拷贝到v里面  cout\u0026lt;\u0026lt;v.end()-v.begin(); //vector的迭代器是随即迭代器可以相减  //上面输出的v中元素的个数:5  v.insert(v.begin()+2,13); PrintVector(v.begin(),v.end()); //在v下标为2的位置插入一个元素13,后面的元素全部后推  v.erase(v.begin()+2); PrintVector(v.begin(),v.end()); //删除位于v中下标为2的元素  vector\u0026lt;int\u0026gt; v2(4,100); //v2有4个元素,都是100  v2.insert(v2.begin(),v.begin()+1,v.begin()+3); //将v的一段插入v2开头  //v下标为1的元素到v下标为3的元素(不包括v下标为3的元素!!!)  PrintVector(v2.begin(),v2.end()); v.erase(v.begin()+1,v.begin()+3); PrintVector(v.begin(),v.end()); //删除v上的一个区间,即2,3  return 0; } 用vector实现二维数组\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;using namespace std; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;v(3); //v中有3个元素,每个元素都是vector\u0026lt;int\u0026gt;空容器  //注意vector\u0026lt;int\u0026gt;后面一定要加一个空格,不然编译器会把两个尖括号当成右移运算符  //下面往v的元素里添加元素  for(int i=0;i\u0026lt;v.size();++i) for(int j=0;j\u0026lt;4;++j) v[i].push_back(j); //下面显示v的元素里的元素  for(int i=0;i\u0026lt;v.size();++i){ for(int j=0;j\u0026lt;v[i].size();++j) cout\u0026lt;\u0026lt;v[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } deque(双向队列)   所有vector的操作都适用于deque\n  deque多了:\npush_front:将元素插入到前面\npop_front:删除最前面的元素\n  list(双向列表) 成员函数\n![image-20210318143445110](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210318143445110.png)\nlist上的操作\n#include\u0026lt;list\u0026gt;#include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;using namepsace std; class A { private: int n; public: A(int n_){n=n_;} friend bool operator\u0026lt;(const A \u0026amp; a1,const A \u0026amp; a2); friend bool operator==(const A \u0026amp; a1,const A \u0026amp; a2); friend ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp; o,const A \u0026amp; a); } bool operator\u0026lt;(const A \u0026amp; a1,const A \u0026amp; a2) {return a1.n\u0026lt;a2.n} bool operator==(const A \u0026amp; a1,const A \u0026amp; a2) {return a1.n==a2.n} ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp; o,const A \u0026amp; a) {o\u0026lt;\u0026lt;a.n;return o;} //下面定义一个函数模板,其参数是\u0026#34;类型可变列表的引用\u0026#34; template \u0026lt;class T\u0026gt; void PrintList(const list\u0026lt;T\u0026gt; \u0026amp; lst)//参数是\u0026#34;类型可变列表的引用\u0026#34; { typename list\u0026lt;T\u0026gt;::const_iterator i; //typename用来说明\u0026#34;list\u0026lt;T\u0026gt;::const_iterator\u0026#34;描述的是个类型  i=lst.begin(); for(i=lst.begin();i!=lst.end();i++) cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; } int main() { list\u0026lt;A\u0026gt; lst1,lst2; //定义了两个元素为A类对象的列表  ... PrintLsit(lst1); } 容器适配器 容器适配器上没有迭代器\nstack   是后进先出的数据结构，\n  可以\n push插入 pop删除 top返回栈顶元素的引用    可用vector，list，deque来实现，缺省情况下，用deque实现。（vector、deque实现的性能比list好）\ntemplate\u0026lt;class T,class Container=deque\u0026lt;T\u0026gt;\u0026gt; //第一个类型参数是栈里的元素类型 //第二个类型参数是栈用什么容器来实现，并表示缺省情况下是deque class stack{ ... };   queue   是先进先出的数据结构，\n  可以\n push插入（发生在队尾） pop删除 front返回栈顶元素的引用 back返回队尾元素的引用    可用list，deque来实现，缺省情况下，用deque实现。（vector、deque实现的性能比list好）\ntemplate\u0026lt;class T,class Container=deque\u0026lt;T\u0026gt;\u0026gt; //第一个类型参数是容器适配器里的元素类型 //第二个类型参数是容器适配器用什么容器来实现，并表示缺省情况下是deque class stack{ ... };   priority_queue   可用vector和deque实现，缺省情况下用vector实现\ntemplate\u0026lt;class T,class Container=vector\u0026lt;T\u0026gt;,class Compare=less\u0026lt;T\u0026gt;\u0026gt; //第一个类型参数是容器适配器里的元素类型 //第二个类型参数是容器适配器用什么容器来实现，并表示缺省情况下是vector //第三个类型参数是优先队列的元素比较器用什么来实现，并表示缺省情况下是小于号 class priority_queue;   priority_queue通常用堆排序技术实现，保证最大的元素总是在最前面，即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的引用，默认的元素比较器是less\n  push,pop时间复杂度：O（logn）\n  top时间复杂度：O（1）\n  所有容器适配器中都有成员函数：\n empty（）：用于判断适配器是否为空 size（）：用于返回适配器中元素个数  算法 类型参数Pred 大多重载的算法都是有两个版本的：\n 一个是  用“==”判断元素是否相等 用“\u0026lt;”来比较大小   另一个多出来一 个类型参数Pred，以及函数形参Pred op  表达式“op(x,y)”的返回值是ture，则x等于y 表达式“op(x,y)”的返回值是false，则x小于y    不变序列算法（以下图片上传失败）  不会修改算法作用的容器或对象 适用于顺序容器和关联容器 时间复杂度：O（n）  ![image-20210315213723396](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210315213723396.png)\n![image-20210315213758362](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210315213758362.png)\n![image-20210315213935514](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210315213935514.png)\n find很重要  排序算法  需要随机访问迭代器的支持 不适用于关联容器和list 时间复杂度：O(log(n))  ![image-20210315215204555](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210315215204555.png)\n![image-20210315215228540](/Users/abigail/OneDrive - sjtu.edu.cn/Abigail/大三下/北大c++笔记/assets/image-20210315215228540.png)\nsort：快速排序\n  模板\ntemplate\u0026lt;class Ranlt\u0026gt; void sort(Ranlt first,Ranlt last);  按升序排列 判断x是否应该比y靠前，就看x\u0026lt;y是否为true  template\u0026lt;class Ranlt,class Pred\u0026gt; void sort(Ranlt first,Ranlt last,Pred pr);  按升序排列 判断x是否应该比y靠前，就看pr(x\u0026lt;y)是否为true    应用：\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; //定义Pred pr class MyLess { public： bool operator()(int n1,int n2) { return(n1%10)\u0026lt;(n2%10); } }; int main() { int a[]={14,2,9,111,78}; int i; sort(a,a+5,MyLess());//按个位数大小排序  for(i=0;i\u0026lt;5;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; sort(a,a+5,greater\u0026lt;int\u0026gt;());//按降序排序  for(i=0;i\u0026lt;5;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 注意：\n  sort实际上是快速排序，时间复杂度为：O(n*log(n))\n 平均性能最优 最坏的情况性能非常差    stable_sort实际上是归并排序\n 能保证相等元素之间的先后次序 存储空间足够时，时间复杂度：n*log(n) 存储空间不够时，时间复杂度：n*log(n)*log(n)    list只能使用内置的排序算法：list::sort\n ","permalink":"https://abigail1985.github.io/essay/pkucpp-2/","summary":"","title":"PKUCpp-2"},{"content":"[TOC]\n预处理指令 https://www.cnblogs.com/zi-xing/p/4550246.html\n本文主要记录了C/C++预处理指令，常见的预处理指令如下：\n #空指令，无任何效果 #include包含一个源代码文件 #define定义宏 #undef取消已定义的宏 #if如果给定条件为真，则编译下面代码 #ifdef如果宏已经定义，则编译下面代码 #ifndef如果宏没有定义，则编译下面代码 #elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 #endif结束一个#if……#else条件编译块 #error停止编译并显示错误信息  什么是预处理指令? 预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。\n以前没有在意的学者注意了,预处理指令是在编译器进行编译之前进行的操作.预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。可见预处理过程先于编译器对源代码进行处理。在很多编程语言中，并没有任何内在的机制来完成如下一些功能：在编译时包含其他源文件、定义宏、根据条件决定编译时是否包含某些代码(防止重复包含某些文件)。要完成这些工作，就需要使用预处理程序。尽管在目前绝大多数编译器都包含了预处理程序，但通常认为它们是独立于编译器的。预处理过程读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行响应的转换。预处理过程还会删除程序中的注释和多余的空白字符。\n预编译指令 #ifdef,#ifndef,#endif\u0026hellip;\n以上这些预编译指令，都是条件编译指令，也就是说，将决定那些代码被编译，而哪些不被编译\nExemple1:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#define DEBUG int main(void) { int i = 0; char c; while(1) { i++; c = getchar(); if(\u0026#39;\\n\u0026#39; != c) { getchar(); } if(\u0026#39;q\u0026#39; == c || \u0026#39;Q\u0026#39; == c) { #ifdef DEBUG//判断DEBUG是否被定义了  printf(\u0026#34;We get:%c,about to exit.\\n\u0026#34;,c); #endif  break; } else { printf(\u0026#34;i = %d\u0026#34;,i); #ifdef DEBUG  printf(\u0026#34;,we get:%c\u0026#34;,c); #endif  printf(\u0026#34;\\n\u0026#34;); } } printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } /*#endif用于终止#if预处理指令。*/ Exemple2:\n#include \u0026lt;stdio.h\u0026gt;#define DEBUG void main() { #ifdef DEBUG  printf(\u0026#34;yes \u0026#34;); #endif #ifndef DEBUG  printf(\u0026#34;no \u0026#34;); #endif } //#ifdefined等价于#ifdef; //#if!defined等价于#ifndef 从C到C++ c++对c扩展主要是为了实现面向对象，但有一些简单的扩展与面向对象关系不大，在这一节中介绍\n引用 int n=4; int \u0026amp;r=n;//r引用了n，r的类型是int   r引用了n，r跟n就是一回事了：改变n，r也会改变，反之亦然。\n  定义引用时，一定要将其初始化。\n  为什么我们要使用”引用“？？\n 可以更方便的交换两个变量值  C中的swap函数：\nvoid swap(int *a,int *b)//参数是两个指针 { int tmp; tmp=*a;*a=*b;*b=temp; } int n1,n2; swap(\u0026amp;n1,\u0026amp;n2)//传入的参数是两个变量的地址 C++中的swap函数：\nvoid swap(int \u0026amp;a,int \u0026amp;b) //参数是两个变量的引用（直接在函数声明中创建） { int tmp; tmp=a;a=b;b=tmp; } int n1,n2; swap(n1,n2); 引用作为函数的返回值  int n=4; int \u0026amp;SetValue(){return n;} int main() { SetValue()=40; cout\u0026lt;\u0026lt;n; return 0; }//输出：40   常引用\n不能通过常引用去修改他引用的内容，但他引用的内容可以改变\nint n=100; const int \u0026amp;r=n; r=200;//编译错误 n=300;//没有问题   const关键字   常量 const int r=2\n  常量指针\nint n,m; const int *p=\u0026amp;n;//p是指向n的常量指针 *p=5;//不能通过常量指针去修改其指向的内容--\u0026gt;编译出错 n=4; p=\u0026amp;m;//常量指针的指向可以变化--\u0026gt;编译通过 const int*p1; int *p2; p2=p1;//不能把常量指针赋值给非常量指针--\u0026gt;编译错误 p1=p2;//反过来可以--\u0026gt;编译通过 p2=(int*)p1;//强制类型转换--\u0026gt;编译通过   3.常引用\n动态内存分配 c中的malloc可以实现；\nc++中的new可以实现：\n  分配一个变量\nP=new int\nint：类型名\nP：类型为int*的指针\nnew将一片大小为sizeof（int）字节的内存空间的地址赋值给P。\n  分配一个数组\nP=new int[N]\nN:要分配的数组元素的个数\n  注意：new T/new T[N]的返回值都是T*，所以 int *p=new p是成立的\nc++用delete释放被new动态分配的内存空间：\n  释放一个变量\ndelete必须指向new出来的空间；\n一个内存空间不能被delete两次\n  释放一个数组\nint* p=new int[20]; p[0]=1; delete[]p;//不要忘记这个中括号   练习：神秘的数组初始化 #include \u0026lt;iostream\u0026gt;using namespace std; int main() { int * a[] = {NULL,NULL,new int,new int[6]}; //上面大括号中是初始化的内容 \t*a[2] = 123; a[3][5] = 456; if(! a[0] ) { cout \u0026lt;\u0026lt; * a[2] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; a[3][5]; } return 0; } 内联函数和重载函数 内联函数\n  函数调用是有时间开销的。如果函数本身只有几条语 句，执行非常快，而且函数被反复执行很多次，相比 之下调用函数所产生的这个开销就会显得比较大。\n  为了减少函数调用的开销，引入了内联函数机制。编 译器处理对内联函数的调用语句时，是将整个函数的 代码插入到调用语句处，而不会产生调用函数的语句。\n  在函数定义前加关键字inline，即可定义内联函数\n  重载函数\n一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。 以下三个函数是重载关系：\n(1)int Max(double f1,double f2){} (2)int Max(int n1,int n2) {} (3)int Max(int n1,int n2,int n3) {}  函数重载使得函数命名变得简单 编译器根据调用语句的中的实参的个数和类型判断应 该调用哪个函数。  Max(3.4,2.5); //调用 (1) Max(2,4); //调用 (2) Max(1,2,3); //调用 (3) Max(3,2.4);//error,二义性 函数的缺省参数\n  C++中，定义函数的时候可以让最右边的连续若干个参 数有缺省值，那么调用函数的时候，若相应位置不写参 数，参数就是缺省值。\nvoid func( int x1, int x2 = 2, int x3 = 3) { } func(10 ) ; //等效于 func(10,2,3) func(10,8) ; //等效于 func(10,8,3) func(10, , 8) ; //不行,只能最右边的连续若干个参数缺省   函数参数可缺省的目的在于提高程序的可扩充性。\n  即如果某个写好的函数要添加新的参数，而原先那些 调用该函数的语句，未必需要使用新增的参数，那么 为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。\n  类和对象的基本概念（1） 结构化程序设计：\n  c使用：程序=数据结构+算法\n  不足：结构混乱，没有封装和隐藏的概念，难以debug，不能重用类似的代码。\n  面向对象的程序设计：\n  c++使用：程序=类+类+类+...+类\n  特点：抽象，封装，继承，多态\n设计方法：\n归纳：将某类客观事物属性归纳出来（用变量描述属性）\n抽象：将这类事物能进行的操作归纳出来（用函数描述操作）\n封装：将属性和函数捆绑在一起，形成一个类\n  通过类定义来的变量就叫做对象，C中的struct也是类，他定义出的变量也叫做对象。\n  C++中，可以像使用基本类型int，char一样使用类\n  类和对象基础 类和对象的基本概念（2）   类成员的可访问范围\nprivate：只能在成员函数内访问（缺省定义）\npublic：可以在任何地方访问\nprotected：以后再说\n  “隐藏”机制的好处：\n强制对成员变量的访问一定要通过成员函数进行\nclass CEmployee{ private: char szName[30];//名字，sz是char字符串前缀  public: int salary; void setName(char *name) void getName(char *name) void averageSalary(CEmployee e1,CEmployee e2) }; void CEmployee::setName(char * name){strcpy(szName,name);} void CEmployee::getName(char * name){strcpy(name,szName);} /*在类的成员函数内部，能够访问当前对象的全部变量/函数*/ void CEmployee::averageSalary(CEmployee e1,CEmployee e2){ cout\u0026lt;\u0026lt;e1.szName; salary=(e1.salary+e2.salary)/2; //在类的成员函数内部，能够访问同类其他对象的全部变量/函数 } int main(){ CEemployee e; strcpy(e.szName,\u0026#34;Tom123456789\u0026#34;);❌❌❌ //在类的成员函数外部，只能访问该类对象的公有变量/函数，szName是私有变量  e.setName(\u0026#34;Tom\u0026#34;);🆗 e.salary=5000;🆗 //setName是公有函数，salary是公有变量  return 0； } 若将上述程序移植到内存紧张的手持设备上，希望将char szName[30]改为char szName[5]：\n由于不存在strcpy(e.szName,\u0026quot;Tom123456789\u0026quot;)这种语句，所以只需要在setName中加一个判断语句，当输入多于5个符号时报错即可。\n  成员函数的重载，参数缺省\n  成员函数可以重载，也可以缺省\n  使用缺省参数时要注意避免函数重载导致的歧义\nclass location{ private:int x,y; public:void init(int x=0,int y=0) void valueX(int val=0){x=val;} void valueX(){return x;} }; location A; A.valueX();❌❌❌ //编译器无法判断调用哪个valueX     构造函数   什么是构造函数？\n构造函数名字与类的名字相同，可以有参数，不可以有返回值\nclass Complex{ private:double real,imag; public:Complex(double r,double i=0); //构造函数名字与类名相同，无返回值——连void都没有！！！ }; Complex::Complex(double r,double i=0){real=r;imag=i;} Complex c1；❌ Complex* ptr_c2=new Complex;❌ Complex c3(2);🆗//i有缺省值0 Complex* ptr_c4=new Complex(3,4);🆗//c++中变量名可以含有下划线_   为什么需要构造函数？\n对象没被初始化就使用会导致程序出错！\n在用类定义对象时，构造函数可以自动进行初始化操作（就像ios捷径里的自动化！），不必担心忘记初始化。\n  如果定义类时没有写构造函数，编译器会自动生成无参数构造函数\nclass Complex{ private:double real,imag; public:void Set(double r,double i) //编译器自动生成默认构造函数 }; Complex c1；🆗 Complex* pc2=new Complex;🆗//c++中指针前缀：p   可以有多个构造函数，需要参数个数/类型不同。(这些构造函数间是重载的关系)\nclass Complex{ private:double real,imag; public:Complex(double r,double i) Complex(double r); Complex(Complex c1,Complex c2); void Set(double r,double i); }; Complex::Complex(double r,double i){real=r;imag=i;} Complex::Complex(double r){real=r;imag=0;} Complex::Complex(Complex c1,Complex c2) { real=c1.real+c2.real; imag=c1.imag+c2.imag; } Complex c1(3,1),c2(4),c3(c1,c2); //c1={3,1},c2={4,0}c3={7,1}   构造函数在数组中的使用\nclass Test{ public:Test(int n){}//(1)  Test(int n,int m){}//(2)  Test(){}//(3) }; Test array1[3]={1,Test(1,2)}; //三个元素分别用(1)(2)(3)初始化 Test* pArray2[3]={new Test(4),new Test(1,2)}; //👉两个元素👈分别用(1)(2)初始化   复制构造函数   什么是复制构造函数？\n一种特殊的构造函数，其形式参数必须为引用类型\n  如果定义类时没有写，编译器会自动生成无参数复制构造函数\n  复制构造函数被调用时，可以不进行复制工作，见4.2的例子\n  什么时候用到复制构造函数？\n  用一个对象去初始化同类的另一个对象时\nComplex c1; Complex c2(c1);   如果函数有一参数是类A的对象，当该函数被调用时，类A的复制构造函数被调用\nclass A{ public:A(){};//构造函数  A(A\u0026amp; a){cout\u0026lt;\u0026lt;\u0026#34;Copy constructor called\u0026#34;\u0026lt;\u0026lt;endl;}//复制构造函数 }; void Func(A a1){} int main() { A a2; Func(a2);//此时复制构造函数被调用，但并没有把a1变成a2复制品！  return 0; } //输出：Copy constructor called   如果函数的返回值是类A的对象，当该函数返回值时，leiA的复制构造函数被调用\nclass A{ public:int v; A(int n){v=n;} A(const A\u0026amp; a){ v=a.v;//和之前的代码不同，此处进行了复制工作  cout\u0026lt;\u0026lt;\u0026#34;Copy constructor called\u0026#34;\u0026lt;\u0026lt;endl;} }; A Func(){ A b(4);//此处使用类A的构造函数，参数是4  return b; } int main() { cout\u0026lt;\u0026lt;Func().v\u0026lt;\u0026lt;endl; //此处复制构造函数被调用，且将Func().v变成了b的复制品  return 0; } //输出：Copy constructor called 4     对象间赋值并不导致复制构造函数被调用\n 假设A 是一个类的名字，下面哪段程序不会调用A的复制构造函数？\n A. A a1,a2; a1 = a2; B.void func( A a) { cout \u0026laquo; \u0026ldquo;good\u0026rdquo; \u0026laquo; endl; } C. A func( ) { A tmp; return tmp; } D.A a1; A a2(a1);  正确答案：A你选对了\n   为什么我们要在复制构造函数中使用常量引用参数A(const A\u0026amp; a)\nvoid test(A a){cout\u0026lt;\u0026lt;\u0026#34;Test\u0026#34;\u0026lt;\u0026lt;endl;} 这样的函数，调用时生成形参会引发复制构造函数调用，开销比较大。\n👉所以可以考虑使用CMyclass \u0026amp; 引用类型作为参数。 👉为了确保实参的值在函数中不被改变，那么可以加上const 关键字：\nclass A{ public:A(){} A(const A\u0026amp; a){}//定义时就使用const }; void test(const A\u0026amp; a){cout\u0026lt;\u0026lt;\u0026#34;Test\u0026#34;\u0026lt;\u0026lt;endl;} //函数中任何试图改变a值的语句都将是变成非法   为什么我们要自己写复制构造函数？？？？？\n👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇\n  类型转换构造函数   什么是类型转换构造函数？\n只有一个参数，且这参数不是引用类型的，一般就是转换构造函数\n此类函数目的是实现类型的自动转换\n  实例：\n#include\u0026lt;iostream\u0026gt;using namespace std; class Complex{ public: double real,imag; Complex(int i);//类型转换构造函数  Complex(double r,double i){real=r;imag=i;} }; Complex::Complex(int i) { cout\u0026lt;\u0026lt;\u0026#34;IntConstructor called\u0026#34;\u0026lt;\u0026lt;endl; real=i;imag=0;//此处实现了“将int类型转化为Complex类型” } int main() { Complex c1(7,8); Complex c2=12;//直接调用类型转换构造函数  c1=9;//9被自动转换为一个👉临时👈Complex对象  cout\u0026lt;\u0026lt;c1.real\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;c1.imag\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;\u0026lt;\u0026lt;c2.real\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;c2.imag\u0026lt;\u0026lt;endl; return 0; } IntConstructor called IntConstructor called 9,0 12,0 析构函数   析构函数是什么？\nclass Ctest{ public: ~Ctest(){cout\u0026lt;\u0026lt;\u0026#34;destructor called\u0026#34;\u0026lt;\u0026lt;endl；} //析构函数与类名相同，前有一\u0026#34;~\u0026#34;号  //析构函数没有参数，没有返回值  //一个类只能有一个析构函数 }; int main(){ Ctest array[2];//生成一个含有两个Ctest类的对象的数组  cout\u0026lt;\u0026lt;\u0026#34;End Main\u0026#34;\u0026lt;\u0026lt;endl; return 0; //此时main函数结束，array消亡，其中每个元素的析构函数都被调用 } End Main destructor called destructor called   析构函数与delete\n对象：\nCtest *pTest; pTest=new Ctest;//构造函数调用 delete Ctest;//此时析构函数被调用！！ 对象数组：\nCtest *pTest; pTest= new Ctest[3]; delete [] Ctest;//👉必须写[]！👈否则只delete一个对象（调用一次析构函数）！！！！   析构函数在对象作为函数返回值返回后被调用\nclass Ctest{ public: ~Ctest(){cout\u0026lt;\u0026lt;\u0026#34;destructor called\u0026#34;\u0026lt;\u0026lt;endl;} }; Ctest Func(Ctest t){return t;}//作为参数的对象t消亡时，调用析构  int main(){ Ctest t1; t1=Func(t1);//函数返回的临时对象Func(t1)被用过后，调用析构  return 0;//main函数结束t1消亡，调用析构 } destructor called destructor called destructor called   构造/析构函数什么时候被调用？ class Demo{ int id; public: Demo(int i);//类型转换构造函数  ~Demo();//析构函数 }; Demo::Demo(int i){ id=i; cout\u0026lt;\u0026lt;\u0026#34;id=\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#34;constructed\u0026#34;\u0026lt;\u0026lt;endl;} Demo::~Demo(){ cout\u0026lt;\u0026lt;\u0026#34;id=\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#34;destructed\u0026#34;\u0026lt;\u0026lt;endl;} Demo d1(1); //d1定义在这里，说明这是一个全局对象  void Func() { static Demo d2(2); Demo d3(3); cout \u0026lt;\u0026lt; \u0026#34;func\u0026#34; \u0026lt;\u0026lt; endl; } int main () { Demo d4(4); d4 = 6; //这个语句成立是因为有类型转换构造函数  cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; endl; {Demo d5(5);}//d5定义在花括号里，说明这是一个局部对象  Func(); cout \u0026lt;\u0026lt; \u0026#34;main ends\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 输出：\nid=1constructed id=4constructed id=6constructed id=6destructed main id=5constructed id=5destructed id=2constructed id=3constructed func id=3destructed main ends id=6destructed id=2destructed id=1destructed 类和对象提高 This指针   为什么引入This指针？\n  刚开始没有c++编译器，需要把c++翻译成c用c编译器编译。\n  由于c++的成员函数在c中并没有对应概念，因此发明了This指针，该指针可以指向成员函数作用的对象，能将一个全局函数转变为成员函数\n    This指针在c++中的作用\n非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针\nclass A { int i; public: void Hello(){ cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; } }; //用this翻译：void Hello(A*this){ cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; }  int main() { A * p = NULL; p-\u0026gt;Hello(); //用this翻译：Hello(p); }//结果会怎样？输出：hello class A { int i; public: void Hello(){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; } }; //用this翻译：void Hello(A*this){ cout \u0026lt;\u0026lt; this-\u0026gt;i \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl;}  //this若为NULL，则出错！！ int main() { A * p = NULL; p-\u0026gt;Hello();//用this翻译：Hello(p); } // 结果会怎样？编译出错！！！！！   静态成员变量和静态成员函数   定义和性质\n  普通成员变量每个对象各自有一份，静态成员变量一共就一份，所有对象共享\n  sizeof运算符不会计算静态成员变量\nclass CMyclass { int n; static int s; }; //sizeof(CMyclass)=4   普通成员函数必须具体作用于某个对象，静态成员函数不具体作用于某个对象\n  静态成员不需要通过对象就能访问\n  静态成员变量本质上是全局变量，哪怕一个对象都不存在，类 的静态成员变量也存在。\n  静态成员函数本质上是全局函数。\n  设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。\n    如何访问静态成员\n  类名::成员名CRectangle::PrintTotal()\n  对象名.成员名CRectangle r;r.PrintTotal()\n  指针-\u0026gt;成员名CRectangle* p;p-\u0026gt;PrintTotal()\n  引用.成员名CRectangle\u0026amp; ref;int n=ref.nTotalNumber;\n虽然后三个的形式与普通成员变量相同，但并不意味着该成员是属于那个对象的，要判断静态还是普通需要看成员的定义\n    静态成员实例\n考虑一个需要随时知道矩形总数和总面积的图形处理程序 可以用全局变量来记录总数和总面积 用静态成员将这两个变量封装进类中，就更容易理解和维护\nclass CRectangle { private: int w,h; static int nTotalArea; static int nTotalNumber; public: CRectangle(int w_,int h_); ~CRectangle(); static void PrintTotal(); CRectangle(CRectangle \u0026amp; r )//复制构造函数 }; CRectangle::CRectangle(int w_,int h_) { w = w_; h = h_; nTotalNumber ++; nTotalArea += w * h; } CRectangle::~CRectangle() { nTotalNumber --; nTotalArea -= w * h; } void CRectangle::PrintTotal() { cout \u0026lt;\u0026lt; nTotalNumber \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; } CRectangle::CRectangle(CRectangle \u0026amp; r ) { w = r.w; h = r.h; nTotalNumber ++; nToTalArea+=w*h; }/*💢💢💢不要忘了定义复制构造函数！！！！！ 👉在使用CRectangle类时，有时会调用复制构造函数 生成临时的隐藏的CRectangle对象： 调用一个以CRectangle类对象作为参数的函数时， 调用一个以CRectangle类对象作为返回值的函数时 👉临时对象在消亡时会调用析构函数，减少nTotalNumber 和 nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber 和 nTotalArea的值。 int CRectangle::nTotalNumber = 0; int CRectangle::nTotalArea = 0; // 必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。 int main() { CRectangle r1(3,3), r2(2,2); /*cout \u0026lt;\u0026lt; CRectangle::nTotalNumber; 👉Wrong , 私有*/ CRectangle::PrintTotal(); r1.PrintTotal(); //虽然这样写，但不代表PrintTotal是普通成员函数  return 0; } Output:\n2,13 2,13   静态成员函数不能访问非静态成员变量，不能调用非静态成员函数\nvoid CRectangle::PrintTotal() { cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; nTotalNumber \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; nTotalArea \u0026lt;\u0026lt; endl; //wrong } CRetangle::PrintTotal(); //解释不通，w 到底是属于那个对象的？ //同理，非静态成员函数会访问非静态成员变量，调用了非静态函数就等于访问了非静态变量   成员对象和封闭类   有成员对象的类称之为封闭类（enclosing）\n  任何生成封闭类对象的语句，都要让编译器知道封闭类中的成员对象如何初始化，所以我们一定要添加封闭类构造函数的初始化列表\n例子：\n class Ctyre{ private: int radius; int width; public:CTyre(int r,int w):radius(r),width(w){} //上方的构造函数添加了初始化列表，将 radius 初始化成 r，width 初始化成 w。这种写法比在函数体内用 r 和 w 对 radius 和 width 进行赋值的风格更好。建议对成员变量的初始化都使用这种写法 }; class Cengine{}; class Ccar{ private: int price；//成员变量  Cengine engine;//成员对象  Ctyre tyre;//成员对象  public: CCar(int p,int tr,int tw);//Ccar的初始化函数 }; CCar::CCar(int p,int tr,int tw):price(p),tyre(tr,w){}; //:和{之间的内容即为Ccar的构造函数的初始化列表，如果没有这列表，“CCar car”这句话就会编译出错，因为tyre的构造函数需要参数，但那句话并没有给出参数，因此无法构造tpre，因此无法构造car  int main(){ Ccar car(20000,17,225); return 0; } 详细解释看这篇文章：http://c.biancheng.net/view/167.html\n   封闭类对象生成时，先执行成员对象的构造函数，在执行封闭类的成员函数\n👇👇👇\n对象成员构造函数的顺序与其在封闭类中的说明顺序一致\n👇👇👇\n封闭类对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数\n👉👉👉**就像汽车一样，造汽车时先造轮胎和引擎，再组装汽车；拆汽车时先把汽车拆成零件，再去把零件拆散**\n  封闭类对象如果用默认复制构造函数初始化，那么其成员对象也会用复制构造函数初始化\n例子：\n class A{ public:A(){cout \u0026lt;\u0026lt; \u0026#34;default\u0026#34; \u0026lt;\u0026lt; endl;} A(A\u0026amp; r){cout \u0026lt;\u0026lt; \u0026#34;copy\u0026#34; \u0026lt;\u0026lt; endl;} }; class B{A a;}; int main(){ B b1; B b2(b1); return 0; } Output：\ndefault copy//说明b2.a是用类A的复制构造函数初始化的，而且调用复制构造函数时的实参就是b1.a    常量成员函数和常量对象   常量对象\n如果不希望某个对象的值被改变，则定义该对象时可以在前面加const关键字\nclass Demo{...} const Demo Obj;//常量对象   常量成员函数\n如果不希望成员函数执行期间修改其作用的对象，则定义该函数时可以在后面加const关键字\n❗❗❗常量成员函数不能使用普通函数/变量，可以使用静态函数/成员，因为静态函数/成员不具体作用于任何对象\nclass Sample { public: int value; void GetValue() const;//常量成员函数  void func(){}; Sample(){}; }; void Sample::GetValue()const { value=0;//❌❌❌不能访问普通成员变量  func();//❌❌❌不能调用普通成员函数 } int main() { const Sample o; o.value=100;//❌常量对象不能被修改  o.func();//❌常量对象上不能执行非常量成员函数，因为电脑不知道那函数会不会改变这个对象  o.GetValue();//✅常量对象上可以执行常量成员函数 }   注意：两个成员函数，名字和参数表一样，但一个是const一个不是，算重载\n  常引用\n用对象的引用作为参数，不必调用复制构造函数，又比指针做参数好看\nclass Sample{...}; void PrintfObj(const Sample\u0026amp; o){...} //这样函数中能确保不会无意间更改o的值   友元（friends）   友元这个机制算是对c语言程序员的一种妥协，为关系相近的类提供了一种调用函数的方便。友元函数不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员\n  友元函数：一个类的友元函数可以访问该类的私有成员\nclass CCar；//提前声明CCar类，以便后面的CDriver使用  class CDriver { public:void ModifyCar(CCar* pCar); //\u0026#39;改装汽车\u0026#39;函数的参数是一个指向CCar类对象的指针，这里就用到了CCar类 }; class CCar { private: int price; friend void CDriver::ModifyCar(CCar* pCar); //可以将一个类A的成员函数(包括构造/析构函数)说明为另一个类B的友元：friend_返回值_A::func()  friend int MostExpensiveCar(CCar cars[],int total); //上面两函数是CCar类的友元函数，可以访问CCar的私有变量price }; //定义第一个友元函数 void CDriver::ModifyCar(CCar* pCar) { pCar-\u0026gt;price+=1000;//汽车改装后价值增加 } //定义第二个友元函数 int MostExpensiveCar(CCar cars[],int total) { int tmpMax=-1; for(int i=0;i\u0026lt;total;++i) if(cars[i].price\u0026gt;tmpMax) tmpMax=cars[i].price; return tmpMax; } int main(){return 0;}   友元类：一个类的友元类可以访问该类的私有成员\nclass CCar { private:int price; friend class CDriver;//声明CDriver为友元类 }; class CDriver { public: CCar myCar; void ModifyCar(){myCar.price+=1000;} //因CDriver是CCar的友元类，故可以访问CCar的私有成员 }; int main(){return 0;}   友元类之间的关系不能传递，不能继承\n ","permalink":"https://abigail1985.github.io/essay/pkucpp-1/","summary":"","title":"PKUCpp-1"},{"content":"显示在摘要上的内容\nDevonthink+Obsidian管理知识体系 背景 最近为了写毕设论文，看了很多论文和网页资料，看的时候经常会遇到一个知识点觉得应该记录下来，或者一个网页觉得可以用到毕设里，或者就是有一些灵感。另外，在写法语毕设的时候，还希望在正文中能看到这段文字的来源。对于第一个需求，我之前是用印象笔记的桌面助手添加卡片，浏览器插件剪藏网页，但是后来印象笔记的广告让我不堪其扰，剪藏网页也有很多格式混乱，图片不显示的情况。\n最重要的是我的卡片和网页放进去后，因为彼此之间没有联系，几乎不会再拿出来看；对于第二个需求，我试图用Notion来布局我的素材和文字，但是布局起来非常非常麻烦。\n我找了很久，先是找怎样把网页原封不动的保存下来，各种稍后读软件raindrop.io，cubox\u0026hellip;最终发现DEvonthink的web archive完美的实现了这个功能。随后了解了双链笔记，感觉双链可以保持卡片之间的关联性，也能让我在论文中引用资源，于是尝试了logseq，obsidian后，最终选择了obsidian（实在没学会怎么用logseq）\n配合使用 在Devonthink中通过“连接库和文件“将Obsidian的vault链接进去，在vault同级文件夹下建立网页剪藏文件夹和资源文件夹也都链接到DEvonthink中。\n平时添加新的卡片通过Devonthink在菜单栏上的Sorter进行，Devonthink可以手动把文档中#后面的内容识别为标签然后添加标签。（没办法添加卡片时自动识别很烦！）\n用devonthink原因如下  菜单栏sorter添加卡片非常方便 剪藏safari网页为webarchive可以保留全部网页格式，还能做标注，还能搜索 devonthink的标签系统可以把关于一个主题不同种类的资料全部整理到一起 devonthink中也有双链（wiki link）功能，在obsidian里添加的链接在devonthink中也能使用 资源保存在本地 一次性买断  用Obsidian原因如下  vault可以和devonthink联动使用，可以通过devonthink添加卡片到vault里 obsidian可以链接devonthink中的资源，插件Devonlink完美实现了这个功能 关系图谱看起来很炫酷  zotero联动 zotero加入zotfile插件后，可以把pdf都放到一个文件夹下面，把这个文件夹链接到devonthink里面，就可以用tag非常方便的管理论文以及与该论文相关的网页存档，卡片，用pdf expert进行的标注也可以保留下来，从此彻底从endnote转移到了zotero\n有待提升  如何与marginnote联动？我把需要细看的论文都放到了marginnote里 如何在devonthink添加卡片时候自动导入tag？ 感觉纯用标签管理编程笔记仓库以后会非常混乱\u0026hellip;前端，安卓，python，java这种和一些主题研究tag混在一起，但是我没有想到很好的组织obsidian文件夹和剪藏/资料文件夹的办法，我希望在obsidian仓库里只有我自己写的东西，另外，每次写完一张卡片思考应该放到哪个文件夹下面也很烦\u0026hellip;所以，我打算就先这样 obsidian不同vault之间设置的同步？我根据三个主题建立了三个库，每次都要重新配置一遍（比如obsidian-git）很烦 ","permalink":"https://abigail1985.github.io/essay/obsidian-devonthink/","summary":"\u003cp\u003e显示在摘要上的内容\u003c/p\u003e","title":"Devonthink+Obsidian管理知识体系"},{"content":"显示在摘要上的内容\nKatex示例 行间公式 $$ Y=X_{1}+X_{2}+\\cdots+X_{r} \\sim N b(r, p) $$ 行内公式$Y=X_{1}+X_{2}+\\cdots+X_{r} \\sim N b(r, p)$行内公式\n行内公式\\[Y=X_{1}+X_{2}+\\cdots+X_{r} \\sim N b(r, p)\\]行内公式\nBlockquoto示例  花开花谢 白天黑夜\n一切自然 又不尽然\n春夏秋冬 经过才懂\n世间冷暖 无非自然\n 李健  《懂得》    示例","permalink":"https://abigail1985.github.io/essay/hello-world/","summary":"\u003cp\u003e显示在摘要上的内容\u003c/p\u003e","title":"Hello world"},{"content":"","permalink":"https://abigail1985.github.io/tags/","summary":"","title":"标签"}]